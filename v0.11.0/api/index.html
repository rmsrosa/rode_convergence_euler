<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Euler method for RODEs</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://github.com/rmsrosa/rode_conv_em/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Euler method for RODEs</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/results/">Main results</a></li><li><a class="tocitem" href="../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../examples/02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../examples/03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../examples/04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../examples/05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../examples/06-popdyn/">Population dynamics with sin of gBm growth and step process harvest</a></li><li><a class="tocitem" href="../examples/07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../examples/08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../examples/09-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../examples/10-risk/">An actuarial risk model</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../noises/fBm/">Simulating fractional Brownian motion</a></li><li><a class="tocitem" href="../noises/colored/">Ornstein-Uhlenbeck colored noise approximation of white noise</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Noises"><span>Noises</span></a></li><li><a class="tocitem" href="#Solver-methods"><span>Solver methods</span></a></li><li><a class="tocitem" href="#Error-estimation"><span>Error estimation</span></a></li><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Extras"><span>Extras</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rmsrosa/rode_conv_em" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Here we include the docstrings of the methods implemented in <code>RODEConvergence.jl</code>, including <a href="#noises">noise processes</a>, <a href="#solver-methods">solver methods</a>, and <a href="#error-estimation">convergence estimate tools</a>.</p><h2 id="Noises"><a class="docs-heading-anchor" href="#Noises">Noises</a><a id="Noises-1"></a><a class="docs-heading-anchor-permalink" href="#Noises" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.WienerProcess" href="#RODEConvergence.WienerProcess"><code>RODEConvergence.WienerProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WienerProcess(t0, tf, y0)</code></pre><p>Construct a Wiener process on the interval <code>t0</code> to <code>tf</code>, with initial condition <code>y0</code>.</p><p>The noise process <code>noise = WienerProcess(t0, tf, y0)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>.</p><p>Since, by definition, <span>$\Delta W_t \sim \mathcal{N}(0, t)$</span>, a sample path is constructed recursively by solving the recursive relation</p><p class="math-container">\[W_{t_i} = W_{t_{i-1}} + \sqrt{dt} z_i, \qquad i = 1, \ldots,\]</p><p>where at each step <code>z_i</code> is drawn from a standard Normal distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.OrnsteinUhlenbeckProcess" href="#RODEConvergence.OrnsteinUhlenbeckProcess"><code>RODEConvergence.OrnsteinUhlenbeckProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrnsteinUhlenbeckProcess(t0, tf, y0, ν, σ)</code></pre><p>Construct an Ornstein Uhlenbeck process <span>$O_t$</span> on the interval <code>t0</code> to <code>tf</code>, with initial condition <code>y0</code>, drift <code>-ν</code> and diffusion <code>σ</code>, as defined by the equation</p><p class="math-container">\[\mathrm{d}O_t = -\nu O_t \;\mathrm{d}t + \sigma \;\mathrm{d}W_t.\]</p><p>The solution is</p><p class="math-container">\[O_t = e^{-\nu t}O_0 + \sigma \int_0^t e^{-\nu (t - s)}\;\mathrm{d}W_s.\]</p><p>The noise process <code>noise = OrnsteinUhlenbeckProcess(t0, tf, y0, ν, σ)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>.</p><p>Notice the integral term is a Normal random variable with zero mean and variance</p><p class="math-container">\[\mathbb{E}\left[ \left( \sigma \int_0^t e^{-\nu (t - s)} \;\mathrm{d}W_s\right)^2\right] = \frac{\sigma^2}{2\nu}\left( 1 - e^{-2\nu t} \right).\]</p><p>Thus, a sample path is constructed with exact distribution by solving the recursion relation</p><p class="math-container">\[O_{t_i} = e^{-\nu \Delta t} O_{t_{i-1}} + \frac{\sigma}{\sqrt{2\nu}} \sqrt{1 - e^{-2\nu \Delta t}} z_i, \qquad i = 1, \ldots,\]</p><p>where at each time step <code>z_i</code> is drawn from a standard Normal distribution.</p><p>The Ornstein-Uhlenbeck process has mean, variance, and covariance given by</p><p class="math-container">\[    \mathbb{E}[O_t] = O_0 e^{-
u t}, \mathrm{Var}[O_t] = \frac{\sigma^2}{2\nu}, \quad \mathrm{Cov}[O_tO_s] = \frac{\sigma^2}{2\nu} e^{-
u |t - s|}.\]</p><p>so that <span>$O_t$</span> and <span>$O_s$</span> are significantly correlated only when <span>$|t - s| \lesssim \tau$</span>, where <span>$\tau = 1/\nu$</span> is a characteristic time scale for the process. When <span>$\tau \rightarrow 0$</span>, i.e. <span>$\nu \rightarrow \infty$</span>,  with <span>$\sigma^2 / 2\nu = \tau\sigma^2/2 \rightarrow 1$</span>, this approximates a Gaussian white noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.HomogeneousLinearItoProcess" href="#RODEConvergence.HomogeneousLinearItoProcess"><code>RODEConvergence.HomogeneousLinearItoProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HomogeneousLinearItoProcess(t0, tf, y0, primitive_a, primitive_bsquare)</code></pre><p>Construct a homogeneous linear Itô process noise <span>$Y_t$</span> on the interval <code>t0</code> to <code>tf</code>, with initial condition <code>y0</code>, as defined by the equation</p><p class="math-container">\[\mathrm{d}Y_t = a(t) Y_t \;\mathrm{d}t + b(t) Y_t \;\mathrm{d}W_t,\]</p><p>provided the primitive of <span>$a=a(t)$</span> and the primitive of <span>$b^2 = b(t)^2$</span> are given, via <code>primitive_a</code> and <code>primitive_bsquare</code>, respectively.</p><p>The noise process <code>noise = HomogeneousLinearItoProcess(t0, tf, y0, primitive_a, primitive_bsquare)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>The exact solution has the form</p><p class="math-container">\[Y_t = y_0 e^{\int_0^t (a(s) - \frac{b(s)^2}{2}) \;\mathrm{d}s + \int_0^t b(s) \;\mathrm{d}W_s}.\]</p><p>The basic statistics for this process can be computed by first computing the statistics for its logarithm, which satisfies</p><p class="math-container">\[\mathbb{E}\left[ \ln Y_t \right] = \ln y_0 + \int_0^t (a(s) - \frac{b(s)^2}{2}) \;\mathrm{d}s,\]</p><p>and</p><p class="math-container">\[\mathrm{Var}\left( \ln Y_t \right) = \int_0^t b(s)^2 \;\mathrm{d}s.\]</p><p>Then, since <span>$\ln Y_t$</span> is Gaussian, <span>$Y_t$</span> is log-normal with</p><p class="math-container">\[\mathbb{E}\left[ Y_t \right] = y_0 e^{\int_0^t a(s) \;\mathrm{d}s},\]</p><p>and</p><p class="math-container">\[\mathrm{Var}\left( Y_t \right) = y_0^2 e^{\int_0^t 2a(s) \;\mathrm{d}s}\left( e^{\int_0^t b(s)^2 \;\mathrm{d}s} - 1 \right).\]</p><p>A distributionally exact solution is computed on the mesh points in a recursive manner by</p><p class="math-container">\[Y_{t_j} = Y_{t_{j-1}} e^{(p_a(t_j) - p_a(t_{j-1})) - (p_{b^2}(t_j) - p_{b^2}(t_{j-1})/2 + Z_j)}, \qquad j = 1, \ldots,\]</p><p>with <span>$Y_0 = y_0$</span>, and where <span>$p_a = p_a(t)$</span> is the given primitive of <span>$a=a(t)$</span>, <span>$p_{b^2} = p_{b^2}(t)$</span> is the given primitive of <span>$b^2 = b(t)^2$</span>, and <span>$Z_j \sim \mathcal{N}(0, p_{b^2}(t_j) - p_{b^2}(t_{j-1}))$</span>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.GeometricBrownianMotionProcess" href="#RODEConvergence.GeometricBrownianMotionProcess"><code>RODEConvergence.GeometricBrownianMotionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeometricBrownianMotionProcess(t0, tf, y0, μ, σ)</code></pre><p>Construct a Geometric Brownian motion process <span>$Y_t$</span> on the interval <code>t0</code> to <code>tf</code>, with initial condition <code>y0</code>, drift <code>μ</code> and diffusion <code>σ</code>, as defined by</p><p class="math-container">\[\mathrm{d}Y_t = \mu Y_t \;\mathrm{d}t + \sigma Y_t \;\mathrm{d}W_t.\]</p><p>The noise process <code>noise = GeometricBrownianMotionProcess(t0, tf, y0, μ, σ)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.CompoundPoissonProcess" href="#RODEConvergence.CompoundPoissonProcess"><code>RODEConvergence.CompoundPoissonProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompoundPoissonProcess(t0, tf, λ, dylaw)</code></pre><p>Construct a Compound Poisson process on the interval <code>t0</code> to <code>tf</code>, with point Poisson counter with rate parameter <code>λ</code> and increments given by the distribution <code>dylaw</code>.</p><p>The noise process <code>noise = CompoundPoissonProcess(t0, tf, λ, dylaw)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The noise process returned by the constructor yields a random sample path of</p><p class="math-container">\[Y_t = \sum_{i=1}^{N_t} \;\mathrm{d}Y_i,\]</p><p>where <span>$N_t$</span> is the number of events up to time <span>$t$</span>.</p><p>Then, based on the number <code>n</code> of events, the increment is performed by adding <code>n</code> samples of the given increment distribution <code>dylaw</code>.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is set to <code>yt[1] = 0</code>, corresponding to the value at time <code>t0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.PoissonStepProcess" href="#RODEConvergence.PoissonStepProcess"><code>RODEConvergence.PoissonStepProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoissonStepProcess(t0, tf, λ, steplaw)</code></pre><p>Construct a point Poisson process on the interval <code>t0</code> to <code>tf</code>, with a point Poisson counter with rate parameter <code>λ</code> and step values given by the distribution <code>steplaw</code>.</p><p>The noise process <code>noise = PoissonStepProcess(t0, tf, λ, steplaw)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The noise returned by the constructor yields a random sample path of <span>$Y_t = Y_{N_t}$</span> obtained by first drawing the number <code>n</code> of events between consecutive times with interval <code>dt</code> according to the Poisson distribution <code>n = N(t+dt) - N(t) = Poisson(λdt)</code>.</p><p>Then, based on the number <code>n</code> of events, the next state is repeated from the previous value, if <code>n</code> is zero, or set to a new sample value of <code>Y</code>, if <code>n</code> is positive. Since it is not cumulative and it has the Markov property, it doesn&#39;t make any difference, for the discretized sample, whether <code>n</code> is larger than <code>1</code> or not.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.ExponentialHawkesProcess" href="#RODEConvergence.ExponentialHawkesProcess"><code>RODEConvergence.ExponentialHawkesProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExponentialHawkesProcess(t0, tf, λ₀, a, δ, dylaw)</code></pre><p>Construct an Exponentially Decaying Hawkes process on the interval <code>t0</code> to <code>tf</code>, with point Poisson counter with rate parameter <code>λ</code>, jump increments given by the distribution <code>dylaw</code>, and exponential decay with rate <code>δ</code>. </p><p>An exponentially decaying Hawkes process is a self-exciting point process <span>$\lambda_t$</span>, representing a time-dependent intensity rate for an inhomogenous Poisson counter with an initial intensity <span>$\lambda_0$</span>, a reversion level <span>$a$</span> with <span>$\lambda_0 \geq a \geq 0$</span>, an exponential decay with rate <span>$\delta &gt; 0$</span>, and positive stationary random jump increments <span>$S_k$</span>, at each arrival time <span>$T_k$</span>. The process is define by</p><p class="math-container">\[    \lambda_t = a + (\lambda_0 - a) e^{-\delta (t-t_0)} + \sum_{t_0 \leq T_k &lt; t} S_k e^{-\delta (t - T_k)}, \quad t \geq t_0.\]</p><p>The noise process <code>noise = ExponentialHawkesProcess(t0, tf, λ, δ, dylaw)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The noise returned by the constructor yields a random sample path by first drawing the interarrival times, along with the increments given by <code>dylaw</code>, during each mesh time interval, and then applying the exponential decay.</p><p>This implementation of the Hawkes process follows <a href="https://projecteuclid.org/journals/electronic-communications-in-probability/volume-18/issue-none/Exact-simulation-of-Hawkes-process-with-exponentially-decayingintensity/10.1214/ECP.v18-2717.full">A. Dassius and H. Zhao, Exact simulation of Hawkes process with exponentially decaying intensity, Electron. Commun. Probab. 18 (2013), no. 62, 1-13.</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.TransportProcess" href="#RODEConvergence.TransportProcess"><code>RODEConvergence.TransportProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransportProcess(t0, tf, ylaw, f, d)</code></pre><p>Construct a transport process on the time interval <code>t0</code> to <code>tf</code>, with function <code>f=f(t, y)</code> where <code>y</code> is a random vector with dimension <code>d</code> and distribution law for each coordinate given by <code>ylaw</code>.</p><p>The noise process <code>noise = TransportProcess(t0, tf, ylaw, f, d)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>Each random sample path is obtained by first drawing <code>d</code> realizations of the distribution <code>ylaw</code> to build the sample value <code>y</code> and then defining the sample path by <code>Y_t = f(t, y)</code> for each <code>t</code> in the time mesh.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.FractionalBrownianMotionProcess" href="#RODEConvergence.FractionalBrownianMotionProcess"><code>RODEConvergence.FractionalBrownianMotionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FractionalBrownianMotionProcess(t0, tf, y0, hurst, d; flags=FFTW.MEASURE)</code></pre><p>Construct a fractional Brownian motion process on the interval <code>t0</code> to <code>tf</code>, with initial condition <code>y0</code>, Hurst parameter <code>hurst</code> and length up to <code>d</code>.</p><p>The noise process <code>noise = FractionalBrownianMotionProcess(t0, tf, y0, hurst, d; flags=FFTW.MEASURE)</code> returned by the constructor is a subtype of <code>AbstractNoise{Univariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated vector <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The number of steps for the sample path is determined by the length of the given vector <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (length(yt) - 1)</code>. The initial condition is <code>yt[1] = y0</code>, corresponding to the value at time <code>t0</code>. The length of <code>yt</code> must be smaller than or equal to the length <code>d</code> given in the constructor and used for the pre-allocation of the auxiliary vectors.</p><p>The method implemented is the one developed by Davies and Harte and uses an FFT transform to drop the order of complexity to O(N log N). For the transform, we use <code>FFTW.jl</code>, and use the flag <code>flags=FFTW.MEASURE</code> for generating the plans. Other common flags can be passed instead.</p><p>This implementation of fractional Brownian motion via Davies-Harte method follows <a href="http://www.columbia.edu/~ad3217/fbm/thesis.pdf">Dieker, T. (2004) Simulation of Fractional Brownian Motion. MSc Theses, University of Twente, Amsterdam</a> and <a href="https://www.semanticscholar.org/paper/ON-SPECTRAL-SIMULATION-OF-FRACTIONAL-BROWNIAN-Dieker-Mandjes/b2d0d6a3d7553ae67a9f6bf0bbe21740b0914163">A. B. Dieker and M. Mandjes, On spectral simulation of fractional Brownian motion, Probability in the Engineering and Informational Sciences, 17 (2003), 417-434</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.ProductProcess" href="#RODEConvergence.ProductProcess"><code>RODEConvergence.ProductProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductProcess(noises...)</code></pre><p>Construct a multivariate process from independent univariate processes.</p><p>The noise process <code>noise = ProductProcess(noises...)</code> returned by the constructor is a subtype of <code>AbstractNoise{Multivariate}</code>.</p><p>Sample paths are obtained by populating a pre-allocated matrix <code>yt</code> with the sample path, via <code>rand!(rng, noise, yt)</code>.</p><p>The number of steps for the sample path is determined by the number of rows of the given matrix <code>yt</code>, and the time steps are uniform and calculated according to <code>dt = (tf - t0) / (size(yt, 1) - 1)</code>.</p><p>Each columns of <code>yt</code> is populated with a sample path from each univariate process in <code>noise</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.UnivariateProcess" href="#RODEConvergence.UnivariateProcess"><code>RODEConvergence.UnivariateProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnivariateProcess{T}</code></pre><p>Supertype for univariate noise processes.</p><p>Alias for <code>AbstractProcess{T, Univariate}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.MultivariateProcess" href="#RODEConvergence.MultivariateProcess"><code>RODEConvergence.MultivariateProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultivariateProcess{T}</code></pre><p>Supertype for multivariate noise processes.</p><p>Alias for <code>AbstractProcess{T, Multivariate}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.rand!" href="#Random.rand!"><code>Random.rand!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand!(rng::AbstractRNG, noise::AbstractProcess{T}, yt::VecOrMat{T})</code></pre><p>Generate sample paths of the <code>noise</code> process.</p><p>Populate the vector or matrix <code>yt</code> with a sample path of the process <code>noise</code>, with random numbers generated from <code>rng</code>. See each noise type for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><h2 id="Solver-methods"><a class="docs-heading-anchor" href="#Solver-methods">Solver methods</a><a id="Solver-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.RandomEuler" href="#RODEConvergence.RandomEuler"><code>RODEConvergence.RandomEuler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomEuler(T::DataType=Float64, n::Int=0)</code></pre><p>Instantiate a <code>RandomEuler</code> method including a cache vector of length <code>n</code> for a non-allocating solver via the Euler method, solved by <code>solve!(xt, t0, tf, x0, f::F, yt::AbstractVector{T}, ::RandomEuler))]</code></p><p>Set <code>n</code> to <code>0</code> for solving a scalar equation and set <code>n</code> to the length of the system (e.g. the length of the initial condition).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.RandomHeun" href="#RODEConvergence.RandomHeun"><code>RODEConvergence.RandomHeun</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomHeun(T::DataType=Float64, n::Int=0)</code></pre><p>Instantiate a <code>RandomHeun</code> method including two cache vectors of length <code>n</code> for a non-allocating solver via the Heun method, solved by <code>solve!(xt, t0, tf, x0, f::F, yt::Vector{T}, ::RandomHeun))</code>.</p><p>Set <code>n</code> to <code>0</code> for solving a scalar equation and set <code>n</code> to the length of the system (e.g. the length of the initial condition).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.CustomMethod" href="#RODEConvergence.CustomMethod"><code>RODEConvergence.CustomMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CustomMethod{F, P, N} &lt;: RODEMethod{N}</code></pre><p>Custom method for solving a Random ODE. It has two fields:</p><ul><li><code>solver</code>: a function <code>solver(xt, t0, tf, x0, f, yt, params)</code> to solve, on the interval <code>t0</code> to <code>tf</code>, a Random ODE with right hand side <code>f</code>, &quot;noise&quot; sample path <code>yt</code>, initial condition <code>x0</code> and extra paramters <code>params</code>;</li><li><code>params</code>: any argument or series of arguments necessary for the custom solver.</li></ul><p>Aliases:</p><ul><li><code>CustomUnivariateMethod{F, P} = CustomMethod{F, P, Univariate}</code></li><li><code>CustomMultivariateMethod{F, P} = CustomMethod{F, P, Multivariate}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><h2 id="Error-estimation"><a class="docs-heading-anchor" href="#Error-estimation">Error estimation</a><a id="Error-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Error-estimation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.ConvergenceSuite" href="#RODEConvergence.ConvergenceSuite"><code>RODEConvergence.ConvergenceSuite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvergenceSuite(t0, tf, x0law, f, noise, target, method, ntgt, ns, ks, m)</code></pre><p>Gather the data needed for computing the convergence error for a given RODE of the form</p><p class="math-container">\[    \begin{cases}
        \frac{\mathrm{d}X_t}{\mathrm{d}t} = f(t, X_t, Y_t), &amp; t_0 \leq t \leq t_f \\
        X_{t_0} = X_0.
    \end{cases}\]</p><p>The data comprises of the following:</p><ul><li>the initial and final times <code>t0</code> and <code>tf</code>;</li><li>the univariate or multivariate distribution <code>x0law</code> for the initial condition <span>$X_0$</span>;</li><li>the right-hand-side term <code>f</code> for the equation, either in the out-of-place form <code>f=f(t, x, y)</code>, for a scalar equation (i.e. with a univariate initial condition <code>x0law</code>), or in the in-place form <code>f=f(dx, t, x, y)</code>, for a system of equations (i.e. with a multivariate initial condition <code>x0law</code>);</li><li>the univariate or multivariate process <code>noise</code> for the noise term <span>$Y_t$</span>;</li><li>the method <code>target</code> to compute the target solution for the error calculation via <code>solve!(xt, t0, tf, x0, f, yt, target)</code>, typically <code>EulerMethod()</code> with a much finer resolution with <code>ntgt</code> mesh points or the order of the square of the highest number of mesh points in <code>ns</code> (see below) or a lower resolution <code>CustomMethod()</code> with an exact distribution of the possible solutions conditioned to the already computed noise points;</li><li>the <code>method</code> to approximate the solution, typically the <code>EulerMethod()</code>, also in the form <code>solve!(xt, t0, tf, x0, f, yt, method)</code>;</li><li>the number <code>ntgt</code> of mesh points in the fine mesh on which the target solution will be computed;</li><li>the vector <code>ns</code> with a list of numbers of mesh points to compute the approximate solutions;</li><li>the number <code>m</code> of sample paths to be computed for estimating the strong error via Monte Carlo method.</li><li>the range of steps <code>ks</code> to be used in case one approximates a Random PDE with an increasing number of spatial discretization points, so for each <code>n</code> in <code>ns</code>, one uses a range <code>begin:k:end</code> for the points in the spatial discretization, which defaults to <code>k=[1]</code> in the case of a scalar or of a genuine system of RODEs;</li></ul><p>Besides these data obtained from the supplied arguments, a few cache vectors or matrices are created:</p><ul><li>a vector or matrix <code>yt</code> to hold the sample paths of the noise on the finest mesh, with length or row-length being <code>ntgt</code> and the shape depending on whether the noise is univariate or multivariate;</li><li>a vector or matrix <code>xt</code> to hold the sample paths of the target solution, on the finest mesh, with length or row-length being <code>ntgt</code> and the shape depending on whether the law for the initial condition being univariate or multivariate;</li><li>a vector or matrix <code>xnt</code> to hold the sample paths of the approximate solution, with length or row-length being the maximum of those in <code>ns</code> and the shape depending on whether the law for the initial condition being univariate or multivariate.</li></ul><p>The actual error is obtained by solving a ConvergenceSuite via <code>solve(rng::AbstractRNG, suite::ConvergenceSuite{T})</code> with a given RNG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.ConvergenceResult" href="#RODEConvergence.ConvergenceResult"><code>RODEConvergence.ConvergenceResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvergenceResult{T, S}(suite::S, deltas::Vector{T}, trajerrors::Matrix{T}, trajstderrs::Matrix{T}, errors::Vector{T}, stderrs::Vector{T}, lc::T, p::T, pmin::T, pmax::T) where {T, S}</code></pre><p>Stores the result of <code>solve(rng, suite)</code> with fields</p><ul><li><code>suite</code>: the <code>ConvergenceSuite</code> which is to be solved for;</li><li><code>deltas</code>: the time steps associated with the number of mesh points in the vector <code>suite.ns</code>;</li><li><code>trajerrors</code>: a matrix where each column corresponds to the strong error, along the trajectory, at each mesh resolution determined by <code>suite.ns</code>, i.e. <code>trajerrors[i, k]</code> is the error at time <span>$t_0 + i \Delta t$</span>, for the time step <span>$\Delta t = (t_f - t_0) / (n - 1)$</span> associated with the kth element <code>n = suite.ns[k]</code>;</li><li><code>trajstderrs</code>: a matrix with the corresponding standard error for each entry in <code>trajerrors</code>;</li><li><code>errors</code>: the maximum, along the trajectory, of the <code>trajerrors</code>;</li><li><code>stderrs</code>: the corresponding standard error for the Monte-Carlo estimate of the strong <code>errors</code>;</li><li><code>lc</code>: the logarithm <span>$\log(C)$</span> of the multiplicative constant in the fitted error <code>CΔtᵖ</code>;</li><li><code>p</code>: the estimated order of the strong convergence;</li><li><code>pmin</code> and <code>pmax</code>: the 95% confidence interval for <code>p</code>;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.solve" href="#RODEConvergence.solve"><code>RODEConvergence.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(rng, suite::ConvergenceSuite)</code></pre><p>Compute the strong errors and the order of convergence of the given suite.</p><p>The result is returned in the form of a <a href="#RODEConvergence.ConvergenceResult"><code>ConvergenceResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.generate_error_table" href="#RODEConvergence.generate_error_table"><code>RODEConvergence.generate_error_table</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_error_table(result, info)</code></pre><p>Generate the markdown table with the data for the strong errors. </p><p>This is obteined from <code>result.errors</code>, with time steps <code>result.deltas</code> and lengths <code>result.suite.ns</code>, and the provided <code>info</code> for the problem, where <code>info</code> is given as a namedtuple with String fields <code>info.equation</code>, <code>info.ic</code>, and <code>info.noise</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.plot_convergence" href="#RODEConvergence.plot_convergence"><code>RODEConvergence.plot_convergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(results::ConvergenceResult)</code></pre><p>Plot the convergence estimate in a log-log scale (time step vs strong error).</p><p>It is based on the values provided in <code>results</code>, as computed by <a href="#RODEConvergence.solve"><code>solve(::ConvergenceSuite)</code></a>.</p><p>The plot consists of a scatter plot for the <code>results.errors</code> and a line plot from the fitted <code>errors ≈ C Δtᵖ</code>, where <code>C = exp(lc)</code>, with <code>Δt</code> in <code>results.deltas</code>, <code>lc = results.lc</code>, and <code>p = results.p</code>, with appropriate legends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.plot_suite" href="#RODEConvergence.plot_suite"><code>RODEConvergence.plot_suite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(suite::ConvergenceSuite; ns = suite.ns, xshow=true, yshow=false, noisealpha=nothing, resolution=2^9)</code></pre><p>Plot the target solution, the noise and a few sample paths.</p><p>Plot the target solution in <code>suite.xt</code>, the noise in <code>suite.yt</code>, and a few sample paths in the interval <code>t0</code> to <code>tf</code>, with different time steps as defined by the number of mesh points in <code>suite.ns</code> or as given by the keyword <code>ns</code> as a vector of integers with the desired numbers of mesh points.</p><p>The noise, the target solution, and the approximations can be displayed or not, according to the keywords <code>xshow</code>, <code>yshow</code> and <code>ns</code>. If any of them is set to <code>false</code> or <code>nothing</code>, then the corresponding series is not showed.</p><p>The <code>linealpha</code> for plotting the noise can be changed via keyword <code>noiselpha</code>.</p><p>If <code>suite</code> refers to a system of equations (i.e. with <code>x0law</code> as a <code>MultivariateDistribution</code> instead of a <code>UnivariateDistribution</code>, one can choose to display one or more specific coordinates by specifying the keyword <code>xshow</code> in several possible ways, e.g. <code>xshow=2</code> (for the second coordinate), or <code>xshow=1:3</code> (for the first to third coordinates as separate series), or even the sum of all the coordinates, with either <code>xshow=:sum</code>, or the Euclidian norm, if <code>xshow=:norm</code>, or in any other way if <code>xshow</code> is a <code>Function</code> acting on each element of <code>x</code>, when <code>x</code> is a scalar, or on each column of <code>x</code>, when <code>x</code> is vector-valued, such as <code>xshow=sqrt</code>, <code>xshow=sum</code> or <code>xshow=x-&gt;2x[1] + x[2]/2</code>, etc.).</p><p>Similary, if <code>noise</code> is a <code>ProductProcess</code>, onde can choose to display one or more specific noise contituents, or combinations of them, by specifying the keyword <code>yshow</code> in the same way as for <code>xshow</code> just described.</p><p>The <code>resolution</code> keyword can be used to set the maximum resolution for the display of paths, which can be originally about a million points, so reducing it to say the default value of <code>2^9=512</code> is plenty enough for the visualization and reduces considerably the size of the generated SVG images. When combining multiple plots into one, it helps reducing even more this value, say <code>resolution=2^7</code> or <code>2^8</code> (128 or 256 points). The resolution must be a factor of <code>suite.ntgt</code> and of all the values of <code>suite.ns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><h2 id="Extras"><a class="docs-heading-anchor" href="#Extras">Extras</a><a id="Extras-1"></a><a class="docs-heading-anchor-permalink" href="#Extras" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.AbstractProcess" href="#RODEConvergence.AbstractProcess"><code>RODEConvergence.AbstractProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractProcess{T, N}</code></pre><p>Abstract super type for every noise process, with parameter <code>N</code> being either <code>Univariate</code> or <code>Multivariate</code> and <code>T</code> being the eltype of the process.</p><p>The following aliases are also defined:</p><ul><li><code>UnivariateProcess{T} = AbstractProcess{T, Univariate}</code></li><li><code>MultivariateProcess{T} = AbstractProcess{T, Multivariate}</code></li></ul><p>The parameter types are borrowed from Distributions.Univariate and Distributions.Multivariate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.RODEMethod" href="#RODEConvergence.RODEMethod"><code>RODEConvergence.RODEMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RODEMethod{N}</code></pre><p>Abstract supertype for the methods for solving a Random ODE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.solve!" href="#RODEConvergence.solve!"><code>RODEConvergence.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve!(xt, t0, tf, x0, f, yt, method)</code></pre><p>Solve a random ODE with the provided <code>method</code>.</p><p>More precisely, sove, inplace, (a sample path of) the (R)ODE <code>dx_t/dt = f(t, x_t, y_t),</code> for an unknown <code>x_t</code> and a given (noise path) <code>y_t</code>, with the following arguments:</p><ul><li>a function <code>f(t, x, y)</code>, if <code>x</code> is a scalar, or <code>f(dx, t, x, y)</code>, if <code>x</code> is a vector;</li><li>a scalar or vector initial condition <code>x0</code>;</li><li>a time interval <code>t0</code> to <code>tf</code>;</li><li>a sample path <code>yt</code> of a &quot;noise&quot;, either a vector (for scalar noise) or a matrix (for vectorial noise).</li><li>a numerical <code>method</code>, either <code>RandomEuler()</code> for a scalar equation, <code>RandomEuler(n)</code> for an n-dimensional system of equations, or <code>RandomHeun()</code> for a scalar equation.</li></ul><p>The values of <code>xt</code> are updated with the computed solution values.</p><p>The time step is obtained from the length of the vector <code>xt</code> via <code>dt = (tf - t0) / (lenght(xt) - 1)</code>.</p><p>The noise <code>yt</code> should be of the same (row) length as <code>xt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RODEConvergence.calculate_trajerrors!" href="#RODEConvergence.calculate_trajerrors!"><code>RODEConvergence.calculate_trajerrors!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_trajerrors!(rng, trajerrors, suite)</code></pre><p>Calculate the strong error at each time step along the trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rmsrosa/rode_conv_em">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noises/colored/">« Ornstein-Uhlenbeck colored noise approximation of white noise</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 10 July 2023 12:26">Monday 10 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
