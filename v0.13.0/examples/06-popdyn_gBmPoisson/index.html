<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Population dynamics with sin of gBm growth and step process harvest · Euler method for RODEs</title><meta name="title" content="Population dynamics with sin of gBm growth and step process harvest · Euler method for RODEs"/><meta property="og:title" content="Population dynamics with sin of gBm growth and step process harvest · Euler method for RODEs"/><meta property="twitter:title" content="Population dynamics with sin of gBm growth and step process harvest · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_conv_em/examples/06-popdyn_gBmPoisson/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_conv_em/examples/06-popdyn_gBmPoisson/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_conv_em/examples/06-popdyn_gBmPoisson/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with sin of gBm growth and step process harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../09-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../10-risk/">An actuarial risk model</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li><li><a class="tocitem" href="../../noises/colored/">Ornstein-Uhlenbeck colored noise approximation of white noise</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Population dynamics with sin of gBm growth and step process harvest</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Population dynamics with sin of gBm growth and step process harvest</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_conv_em/docs/literate/examples/06-popdyn_gBmPoisson.jl" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Population-dynamics-with-sin-of-gBm-growth-and-step-process-harvest"><a class="docs-heading-anchor" href="#Population-dynamics-with-sin-of-gBm-growth-and-step-process-harvest">Population dynamics with sin of gBm growth and step process harvest</a><a id="Population-dynamics-with-sin-of-gBm-growth-and-step-process-harvest-1"></a><a class="docs-heading-anchor-permalink" href="#Population-dynamics-with-sin-of-gBm-growth-and-step-process-harvest" title="Permalink"></a></h1><p>This time we consider a population dynamics model with two types of noise, a geometric Brownian motion process affecting the growth rate and a point Poisson step process affecting the harvest.</p><h2 id="The-equation"><a class="docs-heading-anchor" href="#The-equation">The equation</a><a id="The-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation" title="Permalink"></a></h2><p>More precisely, we consider the RODE</p><p class="math-container">\[  \begin{cases}
    \displaystyle \frac{\mathrm{d}X_t}{\mathrm{d} t} = \Lambda_t X_t (r - X_t) - \alpha H_t, \qquad 0 \leq t \leq T, \\
  \left. X_t \right|_{t = 0} = X_0,
  \end{cases}\]</p><p>with</p><p class="math-container">\[  \Lambda_t = \lambda(1 + \epsilon\sin(G_t))\]</p><p>where <span>$\{G_t\}_{t\geq 0}$</span> is a geometric Brownian motion process and <span>$\{H_t\}_{t \geq 0}$</span> is a point Poisson step process with Beta-distributed steps.</p><p>We fix <span>$\lambda = 1.0$</span>, <span>$\epsilon = 0.3$</span>, <span>$r = 1.0$</span>, and <span>$\alpha = 0.5$</span>. Notice the critical value for the bifurcation oscilates between <span>$\lambda (1 - \epsilon) / 4$</span> and <span>$\lambda (1 + \epsilon) / 4$</span>, while the harvest term oscillates between 0 and <span>$\alpha$</span>, and we choose <span>$\alpha = \lambda / 2$</span> so it oscillates below and above the critical value.</p><p>We choose a Beta distribution as the step law, with mean a little below <span>$1/2$</span>, so it stays mostly below the critical value, but often above it.</p><p>The geometric Brownian motion process is chosen with drift <span>$\mu = 1$</span>, diffusion <span>$\sigma = 0.8$</span> and initial value <span>$y_0 = 1.0$</span>.</p><p>The Poisson counter for the point Poisson step process is chosen with rate 15.0, while the time interval is chosen with unit time span.</p><p>As for the initial condition, we also choose a Beta distribution, so it stays within the growth region, and with the same parameters as for the steps, just for the sake of simplicity.</p><p>We do not have an explicit solution for the equation so we use as target for the convergence an approximate solution via Euler method at a much higher resolution.</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages</p><pre><code class="language-julia hljs">using Plots
using Random
using Distributions
using RODEConvergence</code></pre><p>Then we set up the problem parameters.</p><p>We set the seed</p><pre><code class="language-julia hljs">rng = Xoshiro(123)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.Xoshiro(0xfefa8d41b8f5dca5, 0xf80cc98e147960c1, 0x20e2ccc17662fc1d, 0xea7a7dcb2e787c01, 0xf4e85a418b9c4f80)</code></pre><p>The right hand side of the evolution equation</p><pre><code class="language-julia hljs">function f(t, x, y)
    γ = 1.0
    ϵ = 0.3
    r = 1.0
    α = γ / 2
    dx = x &gt; zero(x) ? γ * (1 + ϵ * sin(y[1])) * x * (r - x) - α * y[2] : zero(x)
    return dx
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>The time interval</p><pre><code class="language-julia hljs">t0, tf = 0.0, 1.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 1.0)</code></pre><p>The law for the initial condition</p><pre><code class="language-julia hljs">x0law = Beta(7.0, 5.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.Beta{Float64}(α=7.0, β=5.0)</code></pre><p>The noise parameters</p><pre><code class="language-julia hljs">μ = 1.0
σ = 0.8
y0 = 1.0
noise1 = GeometricBrownianMotionProcess(t0, tf, y0, μ, σ)

λ = 15.0
steplaw = Beta(5.0, 7.0)
noise2 = PoissonStepProcess(t0, tf, λ, steplaw)

noise = ProductProcess(noise1, noise2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}((GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.8), PoissonStepProcess{Float64, Distributions.Beta{Float64}}(0.0, 1.0, 15.0, Distributions.Beta{Float64}(α=5.0, β=7.0))))</code></pre><p>The mesh resolution</p><pre><code class="language-julia hljs">ntgt = 2^18
ns = 2 .^ (4:9)
nsample = ns[[1, 2, 3, 4]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  16
  32
  64
 128</code></pre><p>The number of samples for the Monte-Carlo estimate</p><pre><code class="language-julia hljs">m = 1_000</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000</code></pre><p>And add some information about the simulation:</p><pre><code class="language-julia hljs">info = (
    equation = &quot;population dynamics&quot;,
    noise = &quot;gBm and step process noises&quot;,
    ic = &quot;\$X_0 \\sim \\mathrm{Beta}($(x0law.α), $(x0law.β))\$&quot;
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(equation = &quot;population dynamics&quot;, noise = &quot;gBm and step process noises&quot;, ic = &quot;\$X_0 \\sim \\mathrm{Beta}(7.0, 5.0)\$&quot;)</code></pre><p>We define the <em>target</em> solution as the Euler approximation, which is to be computed with the target number <code>ntgt</code> of mesh points, and which is also the one we want to estimate the rate of convergence, in the coarser meshes defined by <code>ns</code>.</p><pre><code class="language-julia hljs">target = RandomEuler()
method = RandomEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Univariate}(Float64[])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the <a href="../../api/#RODEConvergence.ConvergenceSuite"><code>ConvergenceSuite</code></a>:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f, noise, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.Beta{Float64}, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}, typeof(Main.var&quot;Main&quot;.f), 2, 1, RandomEuler{Float64, Distributions.Univariate}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 1.0, Distributions.Beta{Float64}(α=7.0, β=5.0), Main.var&quot;Main&quot;.f, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}((GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.8), PoissonStepProcess{Float64, Distributions.Beta{Float64}}(0.0, 1.0, 15.0, Distributions.Beta{Float64}(α=5.0, β=7.0)))), RandomEuler{Float64, Distributions.Univariate}(Float64[]), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 262144, [16, 32, 64, 128, 256, 512], 1000, [1, 1, 1, 1, 1, 1], [-1.557318438411405 6.674146942342719e-17; 2.7489157956332813e-17 1.507968535419718; … ; -6.975807326039032e-17 -0.40914139173494185; 0.23689144075942556 1.844984038247103e-16], [7.2644472e-316, 1.15126173e-315, 7.2644472e-316, 1.15126173e-315, 0.29857915127221735, 2.817812841673077e-16, -0.9906047874751011, -1.7604635311312176e-16, -1.174561386260156, 1.6943959902842853e-16  …  8.697949257406858e-18, 1.027458652205215, 2.4488677502010525e-17, 1.7688216259600258, 1.1291502378902525e-16, 0.5709569630148369, -3.3134426218162604e-16, 0.9649288555438676, 2.7525389020012753e-16, -0.2995115447478778], [0.0, 3.93442576e-316, 3.96364283e-316, 1.0e-323, 1.047e-321, 5.0e-324, 7.66e-322, 0.0, 3.93442576e-316, 3.96364283e-316  …  8.77876022991548e-77, -6.962556519166834e-264, 7.5581780777671e-154, -5.705730745527115e273, 10.133132838382307, -2.5313021847275447e35, 4.408174e-317, 2.873487266576134e-306, -2.4923024920967173e35, 4.460149575560355e43])</code></pre><p>Then we are ready to compute the errors via <a href="../../api/#RODEConvergence.solve"><code>solve</code></a>:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceResult{Float64, ConvergenceSuite{Float64, Distributions.Beta{Float64}, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}, typeof(Main.var&quot;Main&quot;.f), 2, 1, RandomEuler{Float64, Distributions.Univariate}, RandomEuler{Float64, Distributions.Univariate}}}(ConvergenceSuite{Float64, Distributions.Beta{Float64}, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}, typeof(Main.var&quot;Main&quot;.f), 2, 1, RandomEuler{Float64, Distributions.Univariate}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 1.0, Distributions.Beta{Float64}(α=7.0, β=5.0), Main.var&quot;Main&quot;.f, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}((GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.8), PoissonStepProcess{Float64, Distributions.Beta{Float64}}(0.0, 1.0, 15.0, Distributions.Beta{Float64}(α=5.0, β=7.0)))), RandomEuler{Float64, Distributions.Univariate}(Float64[]), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 262144, [16, 32, 64, 128, 256, 512], 1000, [1, 1, 1, 1, 1, 1], [1.0 0.0; 0.9992246138348485 0.0; … ; 0.9905522294731544 0.16905153784990012; 0.9921933539828722 0.16905153784990012], [0.6068130006299374, 0.6068141405423507, 0.6068152803391411, 0.6068164199437622, 0.6068175597212103, 0.6068186998924079, 0.606819839815342, 0.6068209794863044, 0.6068221186483839, 0.6068232581671041  …  0.7029834581943913, 0.7029841308487123, 0.7029848038612427, 0.7029854769665147, 0.702986150263091, 0.7029868236644227, 0.7029874973696877, 0.7029881712022819, 0.7029888450750803, 0.7029895189652988], [0.6068130006299374, 0.6073966357856008, 0.6079784241888126, 0.6085628691567583, 0.6091453236689713, 0.6097265075926139, 0.6103066741250266, 0.6108879547281071, 0.6114717922006497, 0.612057783749636  …  0.6997110583704, 0.7000697395200937, 0.7004262714332492, 0.7007804785665365, 0.7011373200648274, 0.7014935502998743, 0.7018454695393331, 0.7021958004031144, 0.7025391518108173, 0.7028840602600873]), [0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125], [0.0 0.0 … 0.0 0.0; 0.0046627507020455886 0.0013565869323902123 … 2.1182616807918277e-5 5.483519809141524e-6; … ; 0.0 0.0 … 0.0 0.0002635595357277291; 0.0 0.0 … 0.0 0.00026329507350790693], [0.0 0.0 … 0.0 0.0; 0.00015599223914301337 6.714506278175557e-5 … 3.0879574534489694e-6 1.0957951249475483e-6; … ; 0.0 0.0 … 0.0 6.106836587788248e-6; 0.0 0.0 … 0.0 6.094490365826517e-6], [0.00893245938918271, 0.004217300560721912, 0.00208766694779176, 0.0010279615494019785, 0.0005167289549223063, 0.00026383636755049843], [0.00019961389444838628, 9.671030803337557e-5, 4.616429178693674e-5, 2.325597474427581e-5, 1.2064214396566486e-5, 6.119032888655615e-6], -1.935985900629406, 1.0147238977539805, 0.9980515955012107, 1.0314156609193104)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{tabular}[htb]{|r|l|l|l|}
        \hline N &amp; dt &amp; error &amp; std err \\
        \hline \hline
        16 &amp; 0.0625 &amp; 0.00893 &amp; 0.0002 \\
        32 &amp; 0.0312 &amp; 0.00422 &amp; 9.67e-5 \\
        64 &amp; 0.0156 &amp; 0.00209 &amp; 4.62e-5 \\
        128 &amp; 0.00781 &amp; 0.00103 &amp; 2.33e-5 \\
        256 &amp; 0.00391 &amp; 0.000517 &amp; 1.21e-5 \\
        512 &amp; 0.00195 &amp; 0.000264 &amp; 6.12e-6 \\
        \hline
    \end{tabular}
    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for population dynamics for each mesh resolution $N$, with initial condition $X_0 \sim \mathrm{Beta}(7.0, 5.0)$ and gBm and step process noises, on the time interval $I = [0.0, 1.0]$, based on $M = 1000$ sample paths for each fixed time step, with the target solution calculated with $262144$ points. The order of strong convergence is estimated to be $p = 1.015$, with the 95\% confidence interval $[0.9981, 1.0314]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 1.0</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We illustrate the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt = plot(result)</code></pre><img src="bd2e6f85.svg" alt="Example block output"/><p>We save the plot for the inclusion in the article</p><p>For the sake of illustration, we plot some approximations of a sample target solution:</p><pre><code class="language-julia hljs">plt = plot(suite, ns=nsample)</code></pre><img src="f9d380f8.svg" alt="Example block output"/><p>This time we save this sample path approximation for illustration in the article</p><pre><code class="language-julia hljs">savefig(plt, joinpath(@__DIR__() * &quot;../../../../latex/img/&quot;, &quot;sample_popdyn_gBmPoisson.png&quot;))</code></pre><p>We can also visualize the noises associated with this sample solution:</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow=true, label=[&quot;Z_t&quot; &quot;H_t&quot;], linecolor=:auto)</code></pre><img src="44d45ee8.svg" alt="Example block output"/><p>The gBm noises enters the equation via <span>$G_t = \gamma(1 + \epsilon\sin(Z_t))$</span>. Using the chosen parameters, this noise can be visualized below</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow= y -&gt; 1.0 + 0.3sin(y[1]), label=&quot;\$G_t\$&quot;)</code></pre><img src="ae0465f5.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 18 May 2024 23:12">Saturday 18 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
