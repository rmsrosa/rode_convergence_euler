<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient · Euler method for RODEs</title><meta name="title" content="Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient · Euler method for RODEs"/><meta property="og:title" content="Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient · Euler method for RODEs"/><meta property="twitter:title" content="Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_conv_em/examples/03-sin_gBm_linearhomogeneous/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_conv_em/examples/03-sin_gBm_linearhomogeneous/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_conv_em/examples/03-sin_gBm_linearhomogeneous/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li class="is-active"><a class="tocitem" href>Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a><ul class="internal"><li><a class="tocitem" href="#The-equation"><span>The equation</span></a></li><li><a class="tocitem" href="#Computing-a-higher-order-approximation-of-the-solution"><span>Computing a higher order approximation of the solution</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with sin of gBm growth and step process harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../09-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../10-risk/">An actuarial risk model</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li><li><a class="tocitem" href="../../noises/colored/">Ornstein-Uhlenbeck colored noise approximation of white noise</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Basic Linear RODEs</a></li><li class="is-active"><a href>Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_conv_em" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Homogenous-linear-RODE-with-the-sine-of-a-Geometric-Brownian-motion-coefficient"><a class="docs-heading-anchor" href="#Homogenous-linear-RODE-with-the-sine-of-a-Geometric-Brownian-motion-coefficient">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a><a id="Homogenous-linear-RODE-with-the-sine-of-a-Geometric-Brownian-motion-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Homogenous-linear-RODE-with-the-sine-of-a-Geometric-Brownian-motion-coefficient" title="Permalink"></a></h1><p>This time we take, as the coefficient of a homogeneous linear equation, the sine of a Geometric Brownian motion process. This is a multiplicative noise, so the classical theory yields a strong order 1/2 convergence for the Euler method, but our results show the strong convergence is actually of order 1, which is, in fact, achieved in the simulations that follow.</p><h2 id="The-equation"><a class="docs-heading-anchor" href="#The-equation">The equation</a><a id="The-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation" title="Permalink"></a></h2><p>We consider the RODE</p><p class="math-container">\[  \begin{cases}
    \displaystyle \frac{\mathrm{d}X_t}{\mathrm{d} t} = \sin(Y_t) X_t, \qquad 0 \leq t \leq T, \\
  \left. X_t \right|_{t = 0} = X_0,
  \end{cases}\]</p><p>where <span>$\{Y_t\}_{t\geq 0}$</span> is a geometric Brownian motion process. The explicit solution is</p><p class="math-container">\[  X_t = e^{\int_0^t \sin(Y_s) \;\mathrm{d}s} X_0.\]</p><h2 id="Computing-a-higher-order-approximation-of-the-solution"><a class="docs-heading-anchor" href="#Computing-a-higher-order-approximation-of-the-solution">Computing a higher order approximation of the solution</a><a id="Computing-a-higher-order-approximation-of-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-a-higher-order-approximation-of-the-solution" title="Permalink"></a></h2><p>As in the previous examples, the integral <span>$\int_0^{t_j} \sin(Y_s)\;\mathrm{d}s$</span> and, hence, the exact solution, is not uniquely defined from the values <span>$W_{t_j}$</span> of the noise on the mesh points. This time, an exact distribution for the collection of exact solutions conditioned on the mesh points is not available in closed form. Hence, we consider an approximation of an exact solution by solving the equation numerically, with the Euler method itself, but in a much higher resolution.</p><p>Indeed, the convergence will be estimated from a set of discretizations with mesh points with time step <span>$\Delta t_N = (t\_f - t\_0) / 2^N$</span>, for <span>$N = N_1 &lt; N_2 &lt; \ldots N_n$</span>, for some <span>$n\in \mathbb{N}$</span>, by comparing the error of such solutions to an approximated solutions computed in a finer mesh with <span>$\Delta t_{\textrm{fine}} = \Delta t_{N_n}^2$</span>, hence with <span>$N_\textrm{fine} = N_n^2$</span>.</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages</p><pre><code class="language-julia hljs">using Plots
using Random
using Distributions
using RODEConvergence</code></pre><p>Then we set up some parameters, with a <a href="https://juliastats.org/Distributions.jl/latest/univariate/#Distributions.Normal">Distributions.Normal</a> random variable as the initial condition.</p><pre><code class="language-julia hljs">rng = Xoshiro(123)

f(t, x, y) = sin(y) * x

t0, tf = 0.0, 1.0
x0law = Normal()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.Normal{Float64}(μ=0.0, σ=1.0)</code></pre><p>The geometric Brownian motion noise is defined via <a href="../../api/#RODEConvergence.GeometricBrownianMotionProcess"><code>GeometricBrownianMotionProcess</code></a>, with initial value <span>$y_0$</span>, drift <span>$\mu$</span>, and dissipation <span>$\sigma$</span> as given by</p><pre><code class="language-julia hljs">μ = 1.0
σ = 0.2
y0 = 1.0
noise = GeometricBrownianMotionProcess(t0, tf, y0, μ, σ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.2)</code></pre><p>The mesh parameters are</p><pre><code class="language-julia hljs">ntgt = 2^18
ns = 2 .^ (4:9)
nsample = ns[[1, 2, 3, 4]]
m = 200</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">200</code></pre><p>We add some information about the simulation:</p><pre><code class="language-julia hljs">info = (
    equation = &quot;\$\\mathrm{d}X_t/\\mathrm{d}t = \\sin(Y_t) X_t\$&quot;,
    noise = &quot;a geometric Brownian motion process noise \$\\{Y_t\\}_t\$ (ic=$y0, drift=$μ; diffusion=$σ)&quot;,
    ic = &quot;\$X_0 \\sim \\mathcal{N}(0, 1)\$&quot;
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(equation = &quot;\$\\mathrm{d}X_t/\\mathrm{d}t = \\sin(Y_t) X_t\$&quot;, noise = &quot;a geometric Brownian motion process noise \$\\{Y_t\\}_t\$ (ic=1.0, drift=1.0; diffusion=0.2)&quot;, ic = &quot;\$X_0 \\sim \\mathcal{N}(0, 1)\$&quot;)</code></pre><p>We define the <em>target</em> solution as the approximation obtained by the Euler method in the much higher resolution <code>ntgt</code> of mesh points. The approximations are also obtained via the Euler method, in the coarser meshes defined by <code>ns</code>.</p><pre><code class="language-julia hljs">target = RandomEuler()
method = RandomEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Univariate}(Float64[])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the <a href="../../api/#RODEConvergence.ConvergenceSuite"><code>ConvergenceSuite</code></a>:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f, noise, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.Normal{Float64}, GeometricBrownianMotionProcess{Float64}, typeof(Main.var&quot;Main&quot;.f), 1, 1, RandomEuler{Float64, Distributions.Univariate}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 1.0, Distributions.Normal{Float64}(μ=0.0, σ=1.0), Main.var&quot;Main&quot;.f, GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.2), RandomEuler{Float64, Distributions.Univariate}(Float64[]), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 262144, [16, 32, 64, 128, 256, 512], 200, [1, 1, 1, 1, 1, 1], [4.9620341e-316, 6.93639818654495e-310, 4.9620341e-316, 3.87951333e-316, -4.059300404958552, -4.796202292652385, -5.405010646476992, 6.93639747199796e-310, 69696.0, -1.469475514528101  …  -3.926775640179983, -4.796202292652385, -5.405010646476992, -6.101425475381264, -6.693554241059729, -7.434239785413003, -8.059701213121432, -8.801682006043404, -9.548191755864973, -10.296723137267337], [4.9620341e-316, 3.99507884e-316, 4.9620341e-316, 3.99507884e-316, -6.8309577595471005, -7.5661059702100815, -8.175968375490132, -8.801682006043404, -9.548191755864973, -10.296723137267337  …  -8.175968375490132, -8.664225369968845, -9.394955081353586, -10.296723137267337, -11.054886919290936, -4.059300404958552, -4.796202292652385, -5.405010646476992, -6.241815004636059, -6.8309577595471005], [3.39519326554e-313, 0.0, 4.5222817e-317, 0.0, 3.2379e-319, 0.0, 0.0, 5.437481e-317, 2.18390573e-316, 1.0e-323  …  1.60185015e-316, 6.93639689606544e-310, 2.043216e-316, 6.93639689579627e-310, 2.06629083e-316, 6.93639689573323e-310, 1.52042813e-316, 6.93639689549924e-310, 2.0921206e-316, 1.0609978975e-314])</code></pre><p>Then we are ready to compute the errors via <a href="../../api/#RODEConvergence.solve"><code>solve</code></a>:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  1.516418 seconds (407.52 k allocations: 27.143 MiB, 35.95% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{tabular}[htb]{|r|l|l|l|}
        \hline N &amp; dt &amp; error &amp; std err \\
        \hline \hline
        16 &amp; 0.0625 &amp; 0.0292 &amp; 0.00215 \\
        32 &amp; 0.0312 &amp; 0.0145 &amp; 0.00107 \\
        64 &amp; 0.0156 &amp; 0.00741 &amp; 0.000559 \\
        128 &amp; 0.00781 &amp; 0.00378 &amp; 0.000278 \\
        256 &amp; 0.00391 &amp; 0.00194 &amp; 0.000144 \\
        512 &amp; 0.00195 &amp; 0.000941 &amp; 6.92e-5 \\
        \hline
    \end{tabular}
    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for $\mathrm{d}X_t/\mathrm{d}t = \sin(Y_t) X_t$ for each mesh resolution $N$, with initial condition $X_0 \sim \mathcal{N}(0, 1)$ and a geometric Brownian motion process noise $\{Y_t\}_t$ (ic=1.0, drift=1.0; diffusion=0.2), on the time interval $I = [0.0, 1.0]$, based on $M = 200$ sample paths for each fixed time step, with the target solution calculated with $262144$ points. The order of strong convergence is estimated to be $p = 0.984$, with the 95\% confidence interval $[0.9309, 1.0389]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 0.98 and 95% confidence interval (0.931, 1.04)</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We illustrate the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt = plot(result)</code></pre><img src="c7dfcb20.svg" alt="Example block output"/><p>For the sake of illustration, we plot some approximations of a sample target solution:</p><pre><code class="language-julia hljs">plot(suite, ns=nsample)</code></pre><img src="825f6131.svg" alt="Example block output"/><p>We can also visualize the noise associated with this sample solution,</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow=true, label=&quot;gBm noise&quot;)</code></pre><img src="ea0cc652.svg" alt="Example block output"/><p>and the sine of the noise, which is the coefficient of he equation</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow=sin, label=&quot;sin of gBm noise&quot;)</code></pre><img src="9fcfae1b.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../02-wiener_linearnonhomogeneous/">« Non-homogenous linear RODE with a Wiener process noise coefficient</a><a class="docs-footer-nextpage" href="../04-allnoises/">Linear system with all implemented noises »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 18 May 2024 23:12">Saturday 18 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
