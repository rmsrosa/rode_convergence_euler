<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Population dynamics with harvest · Euler method for RODEs</title><meta name="title" content="Population dynamics with harvest · Euler method for RODEs"/><meta property="og:title" content="Population dynamics with harvest · Euler method for RODEs"/><meta property="twitter:title" content="Population dynamics with harvest · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/06-popdyn/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/06-popdyn/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/examples/06-popdyn/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li class="is-active"><a class="tocitem" href>Population dynamics with harvest</a><ul class="internal"><li><a class="tocitem" href="#The-equation"><span>The equation</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li></ul></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../09-risk/">An actuarial risk model</a></li><li><a class="tocitem" href="../10-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Population dynamics with harvest</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Population dynamics with harvest</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Population-dynamics-with-harvest"><a class="docs-heading-anchor" href="#Population-dynamics-with-harvest">Population dynamics with harvest</a><a id="Population-dynamics-with-harvest-1"></a><a class="docs-heading-anchor-permalink" href="#Population-dynamics-with-harvest" title="Permalink"></a></h1><p>This time we consider a population dynamics model with two types of noise, a geometric Brownian motion process affecting the growth rate and a point Poisson step process affecting the harvest.</p><h2 id="The-equation"><a class="docs-heading-anchor" href="#The-equation">The equation</a><a id="The-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation" title="Permalink"></a></h2><p>More precisely, we consider the RODE</p><p class="math-container">\[  \begin{cases}
    \displaystyle \frac{\mathrm{d}X_t}{\mathrm{d} t} = \Lambda_t X_t (r - X_t) - \alpha H_t\frac{2X_t}{r + X_t}, \qquad 0 \leq t \leq T, \\
  \left. X_t \right|_{t = 0} = X_0,
  \end{cases}\]</p><p>with</p><p class="math-container">\[  \Lambda_t = \gamma(1 + \epsilon\sin(G_t))\]</p><p>where <span>$\{G_t\}_{t\geq 0}$</span> is a geometric Brownian motion process and <span>$\{H_t\}_{t \geq 0}$</span> is a point Poisson step process with Beta-distributed steps.</p><p>We fix <span>$\gamma = 1.0$</span>, <span>$\epsilon = 0.3$</span>, and <span>$r = 1.0$</span>. Notice the critical value for the bifurcation oscilates between <span>$\gamma (1 - \epsilon) / 4$</span> and <span>$\gamma (1 + \epsilon) / 4$</span>, while the harvest term oscillates between 0 and <span>$\alpha$</span>, and we choose <span>$\alpha = \gamma / 2$</span> so it oscillates below and above the critical value.</p><p>We choose a Beta distribution as the step law, with mean a little below <span>$1/2$</span>, so it stays mostly below the critical value, but often above it.</p><p>The geometric Brownian motion process is chosen with drift <span>$\mu = 1.0$</span>, diffusion <span>$\sigma = 0.8$</span> and initial value <span>$y_0 = 1.0$</span>.</p><p>The Poisson counter for the point Poisson step process is chosen with rate <span>$\lambda = 15.0,$</span> while the time interval is chosen with unit time span.</p><p>As for the initial condition, we also choose a Beta distribution, so it stays within the growth region.</p><p>We do not have an explicit solution for the equation so we use as target for the convergence an approximate solution via Euler method at a much higher resolution.</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages</p><pre><code class="language-julia hljs">using JLD2
using Plots
using Random
using Distributions
using RODEConvergence</code></pre><p>Then we set up the problem parameters.</p><p>We set the seed:</p><pre><code class="language-julia hljs">rng = Xoshiro(123)</code></pre><p>The right hand side of the evolution equation:</p><pre><code class="language-julia hljs">γ = 0.8
ϵ = 0.3
r = 1.0
α = γ * r^2
params = (γ, ϵ, r, α)

function f(t, x, y, p)
    γ = p[1]
    ϵ = p[2]
    r = p[3]
    α = p[4]
    dx = x &gt; zero(x) ? γ * (1 + ϵ * sin(y[1])) * x * (1 - x / r) - α * y[2] * x / (r + x) : zero(x)
    return dx
end</code></pre><p>The time interval:</p><pre><code class="language-julia hljs">t0, tf = 0.0, 1.0</code></pre><p>The law for the initial condition:</p><pre><code class="language-julia hljs">x0law = Beta(7.0, 5.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.Beta{Float64}(α=7.0, β=5.0)</code></pre><p>The noise parameters:</p><pre><code class="language-julia hljs">μ = 1.0
σ = 0.8
y0 = 1.0
noise1 = GeometricBrownianMotionProcess(t0, tf, y0, μ, σ)

λ = 15.0
steplaw = Beta(5.0, 7.0)
noise2 = PoissonStepProcess(t0, tf, λ, steplaw)

noise = ProductProcess(noise1, noise2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}((GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.8), PoissonStepProcess{Float64, Distributions.Beta{Float64}}(0.0, 1.0, 15.0, Distributions.Beta{Float64}(α=5.0, β=7.0))))</code></pre><p>The mesh resolutions:</p><pre><code class="language-julia hljs">ntgt = 2^18
ns = 2 .^ (4:9)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Int64}:
  16
  32
  64
 128
 256
 512</code></pre><p>and</p><pre><code class="language-julia hljs">nsample = ns[[1, 2, 3, 4]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  16
  32
  64
 128</code></pre><p>The number of simulations for the Monte Carlo estimate is set to</p><pre><code class="language-julia hljs">m = 100</code></pre><p>And add some information about the simulation, for the caption of the convergence figure.</p><pre><code class="language-julia hljs">info = (
    equation = &quot;population dynamics&quot;,
    noise = &quot;gBm and step process noises&quot;,
    ic = &quot;\$X_0 \\sim \\mathrm{Beta}($(x0law.α), $(x0law.β))\$&quot;
)</code></pre><p>We define the <em>target</em> solution as the Euler approximation, which is to be computed with the target number <code>ntgt</code> of mesh points, and which is also the one we want to estimate the rate of convergence, in the coarser meshes defined by <code>ns</code>.</p><pre><code class="language-julia hljs">target = RandomEuler()
method = RandomEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Univariate}(Float64[])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the <a href="../../api/#RODEConvergence.ConvergenceSuite"><code>ConvergenceSuite</code></a>:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f, noise, params, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.Beta{Float64}, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}, NTuple{4, Float64}, typeof(Main.var&quot;Main&quot;.f), 2, 1, RandomEuler{Float64, Distributions.Univariate}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 1.0, Distributions.Beta{Float64}(α=7.0, β=5.0), Main.var&quot;Main&quot;.f, ProductProcess{Float64, Tuple{GeometricBrownianMotionProcess{Float64}, PoissonStepProcess{Float64, Distributions.Beta{Float64}}}}((GeometricBrownianMotionProcess{Float64}(0.0, 1.0, 1.0, 1.0, 0.8), PoissonStepProcess{Float64, Distributions.Beta{Float64}}(0.0, 1.0, 15.0, Distributions.Beta{Float64}(α=5.0, β=7.0)))), (0.8, 0.3, 1.0, 0.8), RandomEuler{Float64, Distributions.Univariate}(Float64[]), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 262144, [16, 32, 64, 128, 256, 512], 100, [1, 1, 1, 1, 1, 1], [0.0 0.0; 2.072357e-317 1.0361945e-317; … ; 1.917999586084227 0.66711992524059; 1.9161258594012545 0.6671255788381211], [0.0, -0.0034165567012568996, 0.0004750683909574842, 0.003351018216643432, -0.008689225261139128, -0.006239010506536111, -0.004000197136550383, 0.005186190018043825, -0.0010912678176961165, -0.008989769092953744  …  0.7349104143432601, 0.738307467004564, 0.7519271646946335, 0.7405707436704351, 0.7264653548834122, 0.7309332613206514, 0.7330667086950339, 0.7280977400548486, 0.7289263190251788, 0.7190432980566048], [6.90495306862476e-310, 6.90495306862476e-310, 6.56184236e-316, 6.56184236e-316, 0.0, 1.403e-321, 5.0e-324, 0.0, 0.0, 9.6794875e-316  …  1.067e-321, 0.0, 0.0, 0.0, 0.0, 6.5620455e-316, 6.5620455e-316, 8.0e-323, 0.0, 1.067e-321])</code></pre><p>Then we are ready to compute the errors via <a href="../../api/#RODEConvergence.solve"><code>solve</code></a>:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  1.406980 seconds (445.72 k allocations: 21.742 MiB, 42.08% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, suite, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{center}
        \begin{tabular}[htb]{|r|l|l|l|}
            \hline N &amp; dt &amp; error &amp; std err \\
            \hline \hline
            16 &amp; 0.0625 &amp; 0.00529 &amp; 0.000367 \\
            32 &amp; 0.0312 &amp; 0.00262 &amp; 0.000172 \\
            64 &amp; 0.0156 &amp; 0.00126 &amp; 7.86e-5 \\
            128 &amp; 0.00781 &amp; 0.000626 &amp; 4.35e-5 \\
            256 &amp; 0.00391 &amp; 0.00029 &amp; 2.2e-5 \\
            512 &amp; 0.00195 &amp; 0.00017 &amp; 1.18e-5 \\
            \hline
        \end{tabular}
    \end{center}

    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for population dynamics for each mesh resolution $N$, with initial condition $X_0 \sim \mathrm{Beta}(7.0, 5.0)$ and gBm and step process noises, on the time interval $I = [0.0, 1.0]$, based on $M = 100$ sample paths for each fixed time step, with the target solution calculated with $262144$ points. The order of strong convergence is estimated to be $p = 1.009$, with the 95\% confidence interval $[0.9603, 1.0571]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 1.0 and 95% confidence interval (0.96, 1.06)</code></pre><pre><code class="language-julia hljs"># save to build/</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We illustrate the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt = plot(result)</code></pre><img src="29f3f117.svg" alt="Example block output"/><p>For the sake of illustration, we plot some approximations of a sample target solution:</p><pre><code class="language-julia hljs">plt = plot(suite, ns=nsample)</code></pre><img src="bc1e74b3.svg" alt="Example block output"/><p>We can also visualize the noises associated with this sample solution:</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow=true, label=[&quot;Z_t&quot; &quot;H_t&quot;], linecolor=:auto)</code></pre><img src="42e633bf.svg" alt="Example block output"/><p>The gBm noises enters the equation via <span>$\Lambda_t = \gamma(1 + \epsilon\sin(G_t))$</span>. Using the chosen parameters, this noise can be visualized below</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow= y -&gt; γ * ( 1  + ϵ * sin(y[1]) ), label=&quot;\$G_t\$&quot;)</code></pre><img src="1b257fce.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../05-fBm_linear/">« Linear RODE with fractional Brownian motion</a><a class="docs-footer-nextpage" href="../07-toggle_switch/">A toggle-switch model for gene expression »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:05">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
