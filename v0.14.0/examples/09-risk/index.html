<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>An actuarial risk model · Euler method for RODEs</title><meta name="title" content="An actuarial risk model · Euler method for RODEs"/><meta property="og:title" content="An actuarial risk model · Euler method for RODEs"/><meta property="twitter:title" content="An actuarial risk model · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/09-risk/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/09-risk/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/examples/09-risk/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li class="is-active"><a class="tocitem" href>An actuarial risk model</a><ul class="internal"><li><a class="tocitem" href="#Numerical-simulations"><span>Numerical simulations</span></a></li></ul></li><li><a class="tocitem" href="../10-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>An actuarial risk model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>An actuarial risk model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="An-actuarial-risk-model"><a class="docs-heading-anchor" href="#An-actuarial-risk-model">An actuarial risk model</a><a id="An-actuarial-risk-model-1"></a><a class="docs-heading-anchor-permalink" href="#An-actuarial-risk-model" title="Permalink"></a></h1><p>A classical model for the surplus <span>$U_t$</span> at time <span>$t$</span> of an insurance company is the Cramér–Lundberg model (see e.g. <a href="https://doi.org/10.1080/10920277.1998.10595671">Gerber &amp; Shiu (1998)</a>) given by</p><p class="math-container">\[  U_t = U_0 + \gamma t - \sum_{i=1}^{N_t} C_i\]</p><p>where <span>$U_0$</span> is the initial capital, <span>$\gamma$</span> is a constant premium rate received from the insurees, <span>$C_i$</span> is a random variable representing the value of the <span>$i$</span>-th claim paid to a given insuree, and <span>$N_t$</span> is the number of claims up to time <span>$t$</span>. The process <span>$\{N_t\}_t$</span> is modeled as a Poisson counter, so that the accumulated claims form a compound Poisson process. It is also common to use inhomogeneous Poisson processes and Hawkes self-exciting process, or combinations of such processes for the incidence of the claim, but the classical model uses a homogeneous Poisson counter.</p><p>The model above, however, does not take into account the variability of the premium rate received by the company, nor the investiment of the accumulated reserves, among other things. Several diffusion type models have been proposed to account for these and other factors. We will consider a simple model, with a randomly perturbed premium and with variable rentability.</p><p>More precisely, we start by rewriting the above expression as the following jump (or impulse) differential equation</p><p class="math-container">\[  \mathrm{d}U_t = \gamma\;\mathrm{d}t - \mathrm{d}C_t,\]</p><p>where</p><p class="math-container">\[  C_t = \sum_{i=1}^{N_t} C_i.\]</p><p>The addition of an interest rate <span>$r$</span> leads to</p><p class="math-container">\[  \mathrm{d}U_t = r U_t \mathrm{d}t + \gamma\;\mathrm{d}t - \mathrm{d}C_t.\]</p><p>Assuming a premium rate perturbed by a white noise and assuming the interest rate as a process <span>$\{R_t\}_t$</span>, we find</p><p class="math-container">\[  \mathrm{d}U_t = R_t U_t\;\mathrm{d}t + \gamma\;\mathrm{d}t + \varepsilon\;\mathrm{d}W_t - \mathrm{d}C_t,\]</p><p>so the equation becomes</p><p class="math-container">\[  \mathrm{d}U_t = (\gamma + R_t U_t)\;\mathrm{d}t + \varepsilon\;\mathrm{d}W_t - \mathrm{d}C_t.\]</p><p>Since we can compute exactly the accumulated claims <span>$C_t$</span>, we subtract it from <span>$U_t$</span> to get rid of the jump term. We also subtract an Ornstein-Uhlenbeck process, in the classical way to transform an SDE into a RODE. So, defining</p><p class="math-container">\[  X_t = U_t - C_t - O_t\]</p><p>where <span>$\{O_t\}_t$</span> is given by</p><p class="math-container">\[  \mathrm{d}O_t = -\nu O_t\;\mathrm{d}t + \varepsilon\;\mathrm{d}W_t,\]</p><p>we obtain</p><p class="math-container">\[  \mathrm{d}X_t = (\gamma + R_t U_t)\;\mathrm{d}t + \nu O_t\;\mathrm{d}t = (\gamma + R_t (X_t + C_t + O_t))\;\mathrm{d}t + \nu O_t\;\mathrm{d}t.\]</p><p>This leads us to the linear random ordinary differential equation</p><p class="math-container">\[  \frac{\mathrm{d}X_t}{\mathrm{d}t} = R_t X_t + R_t (C_t + O_t) + \nu O_t + \gamma.\]</p><p>This equation has the explicit solution</p><p class="math-container">\[  X_t = X_0 e^{\int_0^t R_s\;\mathrm{d}s} + \int_0^t e^{\int_s^t R_\tau\;\mathrm{d}\tau} (R_s (C_s + O_s) + \nu O_s + \gamma)\;\mathrm{d}s.\]</p><p>As for the interest rate process <span>$\{R_t\}_t$</span>, there is a vast literature with models for it, see e.g. Chapter 3 of <a href="https://doi.org/10.1007/978-3-540-34604-3">Brigo &amp; Mercurio (2006)</a>, in particular Table 3.1. Here, we consider the Dothan model (Section 3.2.2 of the aforementioned reference), which consists simply of a geometric Brownian motion process</p><p class="math-container">\[  \mathrm{d}R_t = \mu R_t \;\mathrm{d}t + \sigma R_t\;\mathrm{d}t,\]</p><p>with <span>$R_t = r_0$</span>, where <span>$\mu, \sigma, r_0$</span> are positive constants. This has an explicit solution</p><p class="math-container">\[  R_t = r_0 e^{(\mu - \sigma^2/2)t + \sigma W_t},\]</p><p>so that the above equation for <span>$\{X_t\}_t$</span> is a genuine random ODE.</p><p>Once the solution of <span>$\{X_t\}_t$</span> is obtained, we find an explicit formula for the surplus <span>$X_t = U_t - C_t - O_t$</span>, namely</p><p class="math-container">\[  U_t = C_t + O_t + X_0 e^{\int_0^t R_s\;\mathrm{d}s} + \int_0^t e^{\int_s^t R_\tau\;\mathrm{d}\tau} (R_s (C_s + O_s) + \nu O_s + \gamma)\;\mathrm{d}s,\]</p><p>with <span>$\{R_t\}_t$</span> as above.</p><h2 id="Numerical-simulations"><a class="docs-heading-anchor" href="#Numerical-simulations">Numerical simulations</a><a id="Numerical-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-simulations" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages:</p><pre><code class="language-julia hljs">using JLD2
using Plots
using Measures
using Random
using LinearAlgebra
using Distributions
using RODEConvergence</code></pre><p>Then we define the random seed:</p><pre><code class="language-julia hljs">rng = Xoshiro(123)</code></pre><p>The evolution law:</p><pre><code class="language-julia hljs">ν = 5.0
γ = 1.0

params = (ν, γ)

function f(t, x, y, p)
    ν = p[1]
    γ = p[2]
    o = y[1]
    r = y[2]
    c = y[3]
    dx = r * (x + c + o) + ν * o + γ
    return dx
end</code></pre><p>The time interval:</p><pre><code class="language-julia hljs">t0, tf = 0.0, 3.0</code></pre><p>The law for the initial condition:</p><pre><code class="language-julia hljs">x0 = 1.0
x0law = Dirac(x0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.Dirac{Float64}(value=1.0)</code></pre><p>The Ornstein-Uhlenbeck, geometric Brownian motion, and compound Poisson processes for the noise term:</p><pre><code class="language-julia hljs">O0 = 0.0
Oν = 5.0
Oε = 0.8
R0 = 0.2
Rμ = 0.02
Rσ = 0.4
Cmax = 0.2
Cλ = 8.0
Claw = Uniform(0.0, Cmax)
noise = ProductProcess(
    OrnsteinUhlenbeckProcess(t0, tf, O0, Oν, Oε),
    GeometricBrownianMotionProcess(t0, tf, R0, Rμ, Rσ),
    CompoundPoissonProcess(t0, tf, Cλ, Claw)
)</code></pre><p>The resolutions for the target and approximating solutions, as well as the number of simulations for the Monte-Carlo estimate of the strong error:</p><pre><code class="language-julia hljs">ntgt = 2^18
ns = 2 .^ (6:9)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  64
 128
 256
 512</code></pre><pre><code class="language-julia hljs">nsample = ns[[1, 2, 3, 4]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  64
 128
 256
 512</code></pre><p>The number of simulations for the Monte Carlo estimate is set to</p><pre><code class="language-julia hljs">m = 400</code></pre><p>And add some information about the simulation, for the caption of the convergence figure.</p><pre><code class="language-julia hljs">info = (
    equation = &quot;a risk model&quot;,
    noise = &quot;coupled Ornstein-Uhlenbeck, geometric Brownian motion, and compound Poisson processes&quot;,
    ic = &quot;\$X_0 = $x0\$&quot;
)</code></pre><p>We define the <em>target</em> solution as the Euler approximation, which is to be computed with the target number <code>ntgt</code> of mesh points, and which is also the one we want to estimate the rate of convergence, in the coarser meshes defined by <code>ns</code>.</p><pre><code class="language-julia hljs">target = RandomEuler()
method = RandomEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Univariate}(Float64[])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the <a href="../../api/#RODEConvergence.ConvergenceSuite"><code>ConvergenceSuite</code></a>:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f, noise, params, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.Dirac{Float64}, ProductProcess{Float64, Tuple{OrnsteinUhlenbeckProcess{Float64}, GeometricBrownianMotionProcess{Float64}, CompoundPoissonProcess{Float64, Distributions.Uniform{Float64}}}}, Tuple{Float64, Float64}, typeof(Main.var&quot;Main&quot;.f), 2, 1, RandomEuler{Float64, Distributions.Univariate}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 3.0, Distributions.Dirac{Float64}(value=1.0), Main.var&quot;Main&quot;.f, ProductProcess{Float64, Tuple{OrnsteinUhlenbeckProcess{Float64}, GeometricBrownianMotionProcess{Float64}, CompoundPoissonProcess{Float64, Distributions.Uniform{Float64}}}}((OrnsteinUhlenbeckProcess{Float64}(0.0, 3.0, 0.0, 5.0, 0.8), GeometricBrownianMotionProcess{Float64}(0.0, 3.0, 0.2, 0.02, 0.4), CompoundPoissonProcess{Float64, Distributions.Uniform{Float64}}(0.0, 3.0, 8.0, Distributions.Uniform{Float64}(a=0.0, b=0.2)))), (5.0, 1.0), RandomEuler{Float64, Distributions.Univariate}(Float64[]), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 262144, [64, 128, 256, 512], 400, [1, 1, 1, 1], [0.0 0.0 0.0; 0.0 0.0 0.0; … ; 0.0 0.0 0.0; 0.0 0.0 0.0], [3.48930187e-316, 1.201136667e-315, 3.295457e-318, 0.004550778389017239, -0.01492986237696683, -0.001959922277121455, -0.00014573203808258928, 7.9e-322, 3.294815e-318, 1.0317260381882604e195  …  -0.0007997755335645732, 0.003569822277312546, -0.010128621773345888, -0.0039525243084493795, -0.007269259539993296, 0.00786414430768025, -0.005226719845497694, 0.0019100608755695866, -0.004330432721860588, 0.0001072725630820502], [2.9564311e-316, 7.59593045e-316, 0.0, 0.0, 5.0e-324, 5.0e-324, 5.0e-324, 0.0, 5.0e-324, 1.0e-323  …  0.0, 5.0e-324, 5.0e-324, 1.5e-323, 5.0e-324, 5.0e-324, 1.5e-323, 5.0e-324, 0.0, 0.0])</code></pre><p>Then we are ready to compute the errors via <a href="../../api/#RODEConvergence.solve"><code>solve</code></a>:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  2.950121 seconds (448.74 k allocations: 21.730 MiB, 18.00% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, suite, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{center}
        \begin{tabular}[htb]{|r|l|l|l|}
            \hline N &amp; dt &amp; error &amp; std err \\
            \hline \hline
            64 &amp; 0.0469 &amp; 0.224 &amp; 0.0164 \\
            128 &amp; 0.0234 &amp; 0.112 &amp; 0.00847 \\
            256 &amp; 0.0117 &amp; 0.0559 &amp; 0.00397 \\
            512 &amp; 0.00586 &amp; 0.0295 &amp; 0.00199 \\
            \hline
        \end{tabular}
    \end{center}

    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for a risk model for each mesh resolution $N$, with initial condition $X_0 = 1.0$ and coupled Ornstein-Uhlenbeck, geometric Brownian motion, and compound Poisson processes, on the time interval $I = [0.0, 3.0]$, based on $M = 400$ sample paths for each fixed time step, with the target solution calculated with $262144$ points. The order of strong convergence is estimated to be $p = 0.976$, with the 95\% confidence interval $[0.8938, 1.0584]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 0.98 and 95% confidence interval (0.894, 1.06)</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We plot the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt_result = plot(result)</code></pre><img src="6933c3b1.svg" alt="Example block output"/><p>For the sake of illustration of the behavior of the system, we visualize a sample solution</p><pre><code class="language-julia hljs">plt_sols = plot(suite, ns=nothing, label=&quot;\$X_t\$&quot;, linecolor=1)</code></pre><img src="c39f6abd.svg" alt="Example block output"/><p>We also illustrate the convergence to a sample solution</p><pre><code class="language-julia hljs">plt_suite = plot(suite)</code></pre><img src="1dfdaaa9.svg" alt="Example block output"/><p>We can also visualize the noises associated with this sample solution:</p><pre><code class="language-julia hljs">plt_noises = plot(suite, xshow=false, yshow=true, label=[&quot;\$O_t\$&quot; &quot;\$R_t\$&quot; &quot;\$C_t\$&quot;], linecolor=[1 2 3])</code></pre><img src="4d01e4cc.svg" alt="Example block output"/><p>The actual surplus is <span>$U_t = X_t - O_t - C_t$</span>, so we may visualize a sample solution of the surplus by subtracting these two noises from the solution of the above RODE.</p><pre><code class="language-julia hljs">plt_surplus = plot(range(t0, tf, length=ntgt+1), suite.xt .- suite.yt[:, 1] .- suite.yt[:, 3], xaxis=&quot;\$t\$&quot;, yaxis=&quot;\$u\$&quot;, label=&quot;\$U_t\$&quot;, linecolor=1)</code></pre><img src="d52d0f2a.svg" alt="Example block output"/><p>Combining the plots</p><pre><code class="language-julia hljs">tt = range(t0, tf, length=8ns[end]+1)

ds = div(ntgt, 8ns[end])

plt_surplus_and_noises = plot(tt, suite.xt[begin:ds:end] .- suite.yt[begin:ds:end, 1] .- suite.yt[begin:ds:end, 3], xaxis=&quot;\$t\$&quot;, yaxis=&quot;\$u\$&quot;, label=&quot;\$U_t\$&quot;, linecolor=1)

plt_surplus_and_noises_twin = twinx(plt_surplus_and_noises)

plot!(plt_surplus_and_noises_twin, tt, suite.yt[begin:ds:end, 1], yaxis=&quot;\$\\textrm{noise}\$&quot;, label=&quot;\$O_t\$&quot;, legend=:top, linecolor=2)
plot!(plt_surplus_and_noises_twin, tt, suite.yt[begin:ds:end, 2], label=&quot;\$R_t\$&quot;, linecolor=3)
plot!(plt_surplus_and_noises_twin, tt, suite.yt[begin:ds:end, 3], label=&quot;\$C_t\$&quot;, linecolor=4)

plt_combined = plot(plt_result, plt_surplus_and_noises, legendfont=6, size=(800, 240), title=[&quot;(a) risk model&quot; &quot;(b) sample paths&quot; &quot;&quot;], titlefont=10, bottom_margin=5mm, left_margin=5mm)</code></pre><img src="21232d49.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../08-earthquake/">« Mechanical structural under random Earthquake-like seismic disturbances</a><a class="docs-footer-nextpage" href="../10-fisherkpp/">Random Fisher-KPP partial differential equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:05">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
