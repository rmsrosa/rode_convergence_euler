<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs</title><meta name="title" content="Non-homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs"/><meta property="og:title" content="Non-homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs"/><meta property="twitter:title" content="Non-homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/02-wiener_linearnonhomogeneous/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/02-wiener_linearnonhomogeneous/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/examples/02-wiener_linearnonhomogeneous/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li class="is-active"><a class="tocitem" href>Non-homogenous linear RODE with a Wiener process noise coefficient</a><ul class="internal"><li><a class="tocitem" href="#The-equation"><span>The equation</span></a></li><li><a class="tocitem" href="#Computing-a-solution-with-the-exact-distribution"><span>Computing a solution with the exact distribution</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li></ul></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../09-risk/">An actuarial risk model</a></li><li><a class="tocitem" href="../10-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Basic Linear RODEs</a></li><li class="is-active"><a href>Non-homogenous linear RODE with a Wiener process noise coefficient</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-homogenous linear RODE with a Wiener process noise coefficient</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Non-homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient"><a class="docs-heading-anchor" href="#Non-homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient">Non-homogenous linear RODE with a Wiener process noise coefficient</a><a id="Non-homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Non-homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient" title="Permalink"></a></h1><p>In our second linear example, a Wiener process noise enters as the non-homogeneous term.</p><h2 id="The-equation"><a class="docs-heading-anchor" href="#The-equation">The equation</a><a id="The-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation" title="Permalink"></a></h2><p>More precisely, we consider the RODE</p><p class="math-container">\[  \begin{cases}
    \displaystyle \frac{\mathrm{d}X_t}{\mathrm{d} t} = - X_t + W_t, \qquad 0 \leq t \leq T, \\
  \left. X_t \right|_{t = 0} = X_0,
  \end{cases}\]</p><p>where <span>$\{W_t\}_{t\geq 0}$</span> is a Wiener process. The explicit solution is</p><p class="math-container">\[  X_t = e^{-t}X_0 + \int_0^t e^{-(t-s)}W_s\;\mathrm{d}s.\]</p><h2 id="Computing-a-solution-with-the-exact-distribution"><a class="docs-heading-anchor" href="#Computing-a-solution-with-the-exact-distribution">Computing a solution with the exact distribution</a><a id="Computing-a-solution-with-the-exact-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-a-solution-with-the-exact-distribution" title="Permalink"></a></h2><p>As in the first example, the integral <span>$\int_0^{t_j} e^s W_s\;\mathrm{d}s$</span> and, hence, the exact solution, is not uniquely defined from the values <span>$W_{t_j}$</span> of the noise on the mesh points, no matter how fine it is. Thus we estimate the strong error by drawing sample solutions with the exact distribution conditioned on the mesh values.</p><p>We do that by first breaking down the sum into parts:</p><p class="math-container">\[\int_0^{t_j} e^s W_s\;\mathrm{d}s = \sum_{i = 0}^{j-1} \int_{t_i}^{t_{i+1}} e^s W_s\;\mathrm{d}s.\]</p><p>On each mesh interval, we consider again the Brownian bridge</p><p class="math-container">\[  B_t = W_t - W_{t_i} - \frac{t - t_i}{t_{i+1}-t_i}(W_{t_{i+1}} - W_{t_i})\]</p><p>on <span>$[t_i, t_{i+1}]$</span>, which is independent of <span>$W_{t_i}$</span> and <span>$W_{t_{i+1}}$</span>.</p><p>Then,</p><p class="math-container">\[  \begin{align*}
      \int_{t_i}^{t_{i+1}} e^s W_s\;\mathrm{d}s &amp; = \int_{t_i}^{t_{i+1}} e^s B_s^i\;\mathrm{d}s + \int_{t_i}^{t_{i+1}} e^s\left( W_{t_i} + \frac{s - t_i}{t_{i+1}-t_i}(W_{t_{i+1}} - W_{t_i})\right)\;\mathrm{d}s \\
      &amp; = W_{t_{i+1}}e^{t_{i+1}} - W_{t_i}e^{t_i} - \frac{W_{t_{i+1}}-W_{t_i}}{t_{i+1}-t_i}\left(e^{t_{i+1}}-e^{t_i}\right) + Z_i,
  \end{align*}\]</p><p>where</p><p class="math-container">\[    Z_i = \int_{t_i}^{t_{i+1}} e^s B_s^i\;\mathrm{d}s.\]</p><p>As before, the term <span>$Z_i$</span> is a Gaussian with zero mean, and we need to compute its variance to completely characterize it. By translation, it suffices to consider a Brownian bridge <span>$\{B_t\}_{t\in [0, \tau]}$</span> on an interval <span>$[0, \tau]$</span>, with <span>$\tau = \Delta t_N$</span>. This is obtained from <span>$B_t = W_t - (t/\tau)W_\tau$</span>. We have, since <span>$\mathbb{E}[W_tW_s] = \min\{t, s\}$</span>, that</p><p class="math-container">\[   \mathbb{E}[B_tB_s] = \min\{t, s\} - \frac{ts}{\tau}.\]</p><p>Hence,</p><p class="math-container">\[      \begin{align*}
      \mathbb{E}\left[\left(\int_0^{\tau} e^s B_s\;\mathrm{d}s\right)^2\right] &amp; = \mathbb{E}\left[\int_0^{\tau} \int_0^\tau e^s e^t B_sB_t\;\mathrm{d}s\;\mathrm{d}\right] \\
      &amp; = \int_0^\tau \int_0^\tau e^s e^t \mathbb{E}[B_sB_t] \;\mathrm{d}s\;\mathrm{d}t \\
      &amp; = \int_0^\tau \int_0^\tau e^s e^t\left(\min\{t, s\} - \frac{ts}{\tau}\right) \;\mathrm{d}s\;\mathrm{d}t \\
      &amp; = \int_0^\tau \int_0^t e^s e^t s\;\mathrm{d}s\;\mathrm{d}t + \int_0^\tau \int_t^\tau e^s e^t t\;\mathrm{d}s\;\mathrm{d}t - \int_0^\tau \int_0^\tau e^s e^t \frac{ts}{\tau} \;\mathrm{d}s\;\mathrm{d}t \\
      &amp; = \int_0^\tau e^t(te^t-e^t+1)\;\mathrm{d}t + \int_0^\tau te^t(e^\tau - e^t)\;\mathrm{d}t \\
      &amp; \qquad - \int_0^\tau \frac{te^t}{\tau}\left(\tau e^\tau - e^\tau + 1\right)\;\mathrm{d}t \\
      &amp; = \frac{\tau^3}{12}.
  \end{align*}\]</p><p>Back to <span>$Z_i$</span>, this means that</p><p class="math-container">\[     Z_i \sim \mathcal{N}\left(0, \frac{(t_{i+1}- t_i)^3}{12}\right) = \frac{\sqrt{(t_{i+1} - t_i)^3}}{\sqrt{12}}\mathcal{N}(0, 1).\]</p><p>Summing up the terms, we find that</p><p class="math-container">\[  \begin{align*}
      \int_0^{t_j} e^s W_s\;\mathrm{d}s &amp; = \sum_{i = 0}^{j-1} \int_{t_i}^{t_{i+1}} e^s W_s\;\mathrm{d}s \\
      &amp; = \sum_{i = 0}^{j-1} \left( W_{t_{i+1}}e^{t_{i+1}} - W_{t_i}e^{t_i} - \frac{W_{t_{i+1}}-W_{t_i}}{t_{i+1}-t_i}\left(e^{t_{i+1}}-e^{t_i}\right) + Z_i\right) \\
      &amp; = W_{t_j}e^{t_j} - \sum_{i = 0}^{j-1} \left( \frac{W_{t_{i+1}}-W_{t_i}}{t_{i+1}-t_i}\left(e^{t_{i+1}}-e^{t_i}\right) + Z_i\right).
  \end{align*}\]</p><p>Thus, once an Euler approximation is computed, along with realizations <span>$\{W_{t_i}\}_{i=0}^n$</span> of a sample path of the noise, we consider an exact sample solution given by</p><p class="math-container">\[  X_{t_j} = e^{-{t_j}}\left(X_0 - \sum_{i=0}^{j-1} \left(\frac{W_{t_{i+1}} - W_{t_i}}{t_{i+1}-t_i}\left(e^{t_{i+1}} - e^{t_i}\right) + Z_i\right)\right) + W_{t_j},\]</p><p>for realizations <span>$Z_i$</span> drawn from a normal distribution and scaled by the standard deviation <span>$\sqrt{(t_{i+1} - t_i)^3/12}$</span>. This is implemented by computing the integral recursively, via</p><p class="math-container">\[    \begin{cases}
        I_j = I_{j-1} + \frac{W_{t_{j-1}} + W_{t_j}}{t_{j} - t_{j-1}}\left(e^{t_{j} - e^{t_{j-1}}}\right) - Z_j, \\
        Z_j = \sqrt{\frac{(t_{j} - t_{j-1})^3}{12}} R_j, \\
        R_j \sim \mathcal{N}(0, 1), \\
    \end{cases}\]</p><p>with <span>$I_0 = 0$</span>, and setting</p><p class="math-container">\[  X_{t_j} = e^{t_j}\left(X_0 - I_j\right) + W_{t_j}.\]</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>We load the necessary packages</p><pre><code class="language-julia hljs">using Plots
using Random
using Distributions
using RODEConvergence</code></pre><p>Then we set up the relevant variables, as in the first example:</p><pre><code class="language-julia hljs">rng = Xoshiro(123)

f(t, x, y, p) = - x + y

t0, tf = 0.0, 1.0
x0law = Normal()

y0 = 0.0
noise = WienerProcess(t0, tf, y0)

params = nothing

ntgt = 2^16
ns = 2 .^ (4:14)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11-element Vector{Int64}:
    16
    32
    64
   128
   256
   512
  1024
  2048
  4096
  8192
 16384</code></pre><p>The numbers of mesh points for a visualization of one of the sample approximations</p><pre><code class="language-julia hljs">nsample = ns[[1, 2, 3, 4]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  16
  32
  64
 128</code></pre><p>The number of simulations for the Monte Carlo estimate is set to</p><pre><code class="language-julia hljs">m = 80</code></pre><p>and the info about the simulation, for the caption of the convergence figure.</p><pre><code class="language-julia hljs">info = (
    equation = &quot;\$\\mathrm{d}X_t/\\mathrm{d}t = -X_t + W_t\$&quot;,
    noise = &quot;a standard Wiener process noise \$\\{W_t\\}_t\$&quot;,
    ic = &quot;\$X_0 \\sim \\mathcal{N}(0, 1)\$&quot;
)</code></pre><p>We define the <em>target</em> solution as described above.</p><pre><code class="language-julia hljs">target_solver! = function (xt::Vector{T}, t0::T, tf::T, x0::T, f::F, yt::Vector{T}, params::Q, rng::AbstractRNG) where {T, F, Q}
    axes(xt) == axes(yt) || throw(
        DimensionMismatch(&quot;The vectors `xt` and `yt` must match indices&quot;)
    )

    n = size(xt, 1)
    dt = (tf - t0) / (n - 1)
    i1 = firstindex(xt)
    xt[i1] = x0
    integral = zero(T)
    ti1 = zero(T)
    zscale = sqrt(dt^3 / 12)
    for i in Iterators.drop(eachindex(xt, yt), 1)
        ti = ti1 + dt
        integral += (yt[i] - yt[i1]) * (exp(ti) - exp(ti1)) / dt +  zscale * randn(rng)
        xt[i] = exp(-ti) * (x0 - integral) + yt[i]
        ti1 = ti
        i1 = i
    end
end</code></pre><p>and with that we construct the <a href="../../api/#RODEConvergence.CustomMethod"><code>CustomMethod</code></a> that solves the problem with this <code>target_solver!</code>:</p><pre><code class="language-julia hljs">target = CustomUnivariateMethod(target_solver!, rng)</code></pre><p>The method for which want to estimate the rate of convergence is, naturally, the Euler method, implemented via <a href="../../api/#RODEConvergence.RandomEuler"><code>RandomEuler</code></a>:</p><pre><code class="language-julia hljs">method = RandomEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Univariate}(Float64[])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the <a href="../../api/#RODEConvergence.ConvergenceSuite"><code>ConvergenceSuite</code></a>:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f, noise, params, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.Normal{Float64}, WienerProcess{Float64}, Nothing, typeof(Main.var&quot;Main&quot;.f), 1, 1, CustomUnivariateMethod{Main.var&quot;Main&quot;.var&quot;#1#2&quot;, Random.Xoshiro}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 1.0, Distributions.Normal{Float64}(μ=0.0, σ=1.0), Main.var&quot;Main&quot;.f, WienerProcess{Float64}(0.0, 1.0, 0.0), nothing, CustomUnivariateMethod{Main.var&quot;Main&quot;.var&quot;#1#2&quot;, Random.Xoshiro}(Main.var&quot;Main&quot;.var&quot;#1#2&quot;(), Random.Xoshiro(0xfefa8d41b8f5dca5, 0xf80cc98e147960c1, 0x20e2ccc17662fc1d, 0xea7a7dcb2e787c01, 0xf4e85a418b9c4f80)), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 65536, [16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384], 80, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [4.54773593e-316, 1.1014044e-316, 3.5e-323, 4.29152480571473e-310, 4.547729e-316, 6.95524438408897e-309, 2.86e-321, 4.50881717470958e-310, 4.5474049e-316, 4.54774463e-316  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.35807730622e-312, 1.39109558144781e-309, 3.181697100895784e107, 3.084845964565716e-303, -2.014104385301299e28, -95.88706977392569, NaN, NaN, 1.129569626e-314, 1.0632572577e-314  …  0.0, 0.0, 0.0, 1.905544e-316, 5.736e-321, 0.0, 4.0e-323, 0.0, 1.905544e-316, 5.736e-321], [0.0, 1.10788653e-316, 0.0, NaN, 0.0, 0.0, 4.54124944e-316, 4.5412526e-316, 3.78286777e-316, 1.3339744604221839e-288  …  4.0742324367199e-310, 4.54771795e-316, 6.95524438408897e-309, 2.856e-321, 2.98777059174567e-310, 4.5477156e-316, 4.54773593e-316, 4.24399162195e-313, 6.15378779405e-313, 0.0])</code></pre><p>Then we are ready to compute the errors via <a href="../../api/#RODEConvergence.solve"><code>solve</code></a>:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  0.713461 seconds (312.01 k allocations: 197.133 MiB, 4.16% gc time, 75.21% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, suite, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{center}
        \begin{tabular}[htb]{|r|l|l|l|}
            \hline N &amp; dt &amp; error &amp; std err \\
            \hline \hline
            16 &amp; 0.0625 &amp; 0.0199 &amp; 0.00167 \\
            32 &amp; 0.0312 &amp; 0.0101 &amp; 0.000867 \\
            64 &amp; 0.0156 &amp; 0.00459 &amp; 0.000436 \\
            128 &amp; 0.00781 &amp; 0.0023 &amp; 0.000201 \\
            256 &amp; 0.00391 &amp; 0.00125 &amp; 9.87e-5 \\
            512 &amp; 0.00195 &amp; 0.00057 &amp; 4.82e-5 \\
            1024 &amp; 0.000977 &amp; 0.000288 &amp; 2.61e-5 \\
            2048 &amp; 0.000488 &amp; 0.000161 &amp; 1.29e-5 \\
            4096 &amp; 0.000244 &amp; 8.24e-5 &amp; 7.0e-6 \\
            8192 &amp; 0.000122 &amp; 3.72e-5 &amp; 3.25e-6 \\
            16384 &amp; 6.1e-5 &amp; 1.81e-5 &amp; 1.63e-6 \\
            \hline
        \end{tabular}
    \end{center}

    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for $\mathrm{d}X_t/\mathrm{d}t = -X_t + W_t$ for each mesh resolution $N$, with initial condition $X_0 \sim \mathcal{N}(0, 1)$ and a standard Wiener process noise $\{W_t\}_t$, on the time interval $I = [0.0, 1.0]$, based on $M = 80$ sample paths for each fixed time step, with the target solution calculated with $65536$ points. The order of strong convergence is estimated to be $p = 1.0$, with the 95\% confidence interval $[0.9681, 1.0323]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 1.0 and 95% confidence interval (0.968, 1.03)</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We draw a plot of the rate of convergence with the help of a plot recipe for <a href="../../api/#RODEConvergence.ConvergenceResult"><code>ConvergenceResult</code></a>:</p><pre><code class="language-julia hljs">plt = plot(result)</code></pre><img src="61c4e3b3.svg" alt="Example block output"/><p>For the sake of illustration, we plot an approximation of a sample target solution:</p><pre><code class="language-julia hljs">plot(suite, ns=nsample)</code></pre><img src="25534484.svg" alt="Example block output"/><p>We can also visualize the noise associated with this sample solution:</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow=true, label=&quot;Wiener noise&quot;)</code></pre><img src="67e6315f.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../01-wiener_linearhomogeneous/">« Homogenous linear RODE with a Wiener process noise coefficient</a><a class="docs-footer-nextpage" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:05">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
