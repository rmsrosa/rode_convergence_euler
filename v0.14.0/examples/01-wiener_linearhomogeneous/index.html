<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs</title><meta name="title" content="Homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs"/><meta property="og:title" content="Homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs"/><meta property="twitter:title" content="Homogenous linear RODE with a Wiener process noise coefficient · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/01-wiener_linearhomogeneous/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/01-wiener_linearhomogeneous/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/examples/01-wiener_linearhomogeneous/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Homogenous linear RODE with a Wiener process noise coefficient</a><ul class="internal"><li><a class="tocitem" href="#The-equation"><span>The equation</span></a></li><li><a class="tocitem" href="#Computing-a-solution-with-the-exact-distribution"><span>Computing a solution with the exact distribution</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li></ul></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../09-risk/">An actuarial risk model</a></li><li><a class="tocitem" href="../10-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Basic Linear RODEs</a></li><li class="is-active"><a href>Homogenous linear RODE with a Wiener process noise coefficient</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Homogenous linear RODE with a Wiener process noise coefficient</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient"><a class="docs-heading-anchor" href="#Homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient">Homogenous linear RODE with a Wiener process noise coefficient</a><a id="Homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Homogenous-linear-RODE-with-a-Wiener-process-noise-coefficient" title="Permalink"></a></h1><p>We start by considering a homogeneous linear equation in which the coefficient is a Wiener process. In this case, it is already know, by other means, that the Euler method converges strongly of order 1, because it can be regarded as system of stochastic differential equations with additive noise. Nevertheless, we use it here for illustrative purposes.</p><h2 id="The-equation"><a class="docs-heading-anchor" href="#The-equation">The equation</a><a id="The-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation" title="Permalink"></a></h2><p>We consider the RODE</p><p class="math-container">\[  \begin{cases}
    \displaystyle \frac{\mathrm{d}X_t}{\mathrm{d} t} = W_t X_t, \qquad 0 \leq t \leq T, \\
  \left. X_t \right|_{t = 0} = X_0,
  \end{cases}\]</p><p>where <span>$\{W_t\}_{t\geq 0}$</span> is a standard Wiener process. The explicit solution is</p><p class="math-container">\[  X_t = e^{\int_0^t W_s \;\mathrm{d}s} X_0.\]</p><h2 id="Computing-a-solution-with-the-exact-distribution"><a class="docs-heading-anchor" href="#Computing-a-solution-with-the-exact-distribution">Computing a solution with the exact distribution</a><a id="Computing-a-solution-with-the-exact-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-a-solution-with-the-exact-distribution" title="Permalink"></a></h2><p>The integral <span>$\int_0^{t_j} W_s\;\mathrm{d}s$</span> and, hence, the exact solution, is not uniquely defined from the values <span>$W_{t_j}$</span> of the noise on the mesh points, no matter how fine it is. Hence, it makes no sense to compute the strong distance to &quot;the exact solution&quot;. But we can estimate that by drawing sample solutions with the exact distribution conditioned on the mesh values.</p><p>We do that by first breaking down the sum into parts:</p><p class="math-container">\[\int_0^{t_j} W_s\;\mathrm{d}s = \sum_{i = 0}^{j-1} \int_{t_i}^{t_{i+1}} W_s\;\mathrm{d}s.\]</p><p>On each mesh interval, we use that</p><p class="math-container">\[  B_t = W_t - W_{t_i} - \frac{t - t_i}{t_{i+1}-t_i}(W_{t_{i+1}} - W_{t_i})\]</p><p>is a Brownian bridge on <span>$[t_i, t_{i+1}]$</span>, independent of <span>$W_{t_i}$</span> and <span>$W_{t_{i+1}}$</span>.</p><p>Since</p><p class="math-container">\[  \mathrm{d}W_t = \mathrm{d}B_t + \frac{W_{t_{i+1}}-W_{t_i}}{t_{i+1}-t_i}\;\mathrm{d}t,\]</p><p>we obtain</p><p class="math-container">\[\begin{align*}
  \int_{t_i}^{t_{i+1}} W_s\;\mathrm{d}s &amp; = \int_{t_i}^{t_{i+1}} B_s^i\;\mathrm{d}s + \int_{t_i}^{t_{i+1}} \left( W_{t_i} + \frac{s - t_i}{t_{i+1}-t_i}(W_{t_{i+1}} - W_{t_i})\right)\;\mathrm{d}s \\
    &amp; = \frac{1}{2}\left(W_{t_i} + W_{t_{i+1}}\right)(t_{i+1} - t_i) + Z_i,
\end{align*}\]</p><p>where</p><p class="math-container">\[    Z_i = \int_{t_i}^{t_{i+1}} B_s^i\;\mathrm{d}s.\]</p><p>Notice the first term is the trapezoidal rule while the second term is a Gaussian with zero mean. We need to compute the variance of <span>$Z_i$</span> to completely characterize it. By translation, it suffices to consider a Brownian bridge <span>$\{B_t\}_{t\in [0, \tau]}$</span> on an interval <span>$[0, \tau]$</span>, with <span>$\tau = \Delta t_N$</span>. This is obtained from <span>$B_t = W_t - (t/\tau)W_\tau$</span>. We have, since <span>$\mathbb{E}[W_tW_s] = \min\{t, s\}$</span>, that</p><p class="math-container">\[   \mathbb{E}[B_tB_s] = \min\{t, s\} - \frac{ts}{\tau}.\]</p><p>Hence,</p><p class="math-container">\[\begin{align*}
    \mathbb{E}\left[\left(\int_0^{\tau} B_s\;\mathrm{d}s\right)^2\right] &amp; = \mathbb{E}\left[\int_0^{\tau} \int_0^\tau B_sB_t\;\mathrm{d}s\;\mathrm{d}\right] \\
    &amp; = \int_0^\tau \int_0^\tau \mathbb{E}[B_sB_t] \;\mathrm{d}s\;\mathrm{d}t \\
    &amp; = \int_0^\tau \int_0^\tau \left(\min\{t, s\} - \frac{ts}{\tau}\right) \;\mathrm{d}s\;\mathrm{d}t  \\
    &amp; = \int_0^\tau \int_0^t s\;\mathrm{d}s\;\mathrm{d}t + \int_0^\tau \int_t^\tau t\;\mathrm{d}s\;\mathrm{d}t - \int_0^\tau \int_0^\tau \frac{ts}{\tau} \;\mathrm{d}s\;\mathrm{d}t \\
    &amp; = \int_0^\tau \frac{t^2}{2}\;\mathrm{d}t + \int_0^\tau t(\tau - t)\;\mathrm{d}t - \int_0^\tau \frac{t\tau^2}{2\tau}\;\mathrm{d}t \\
    &amp; = \frac{\tau^3}{12}.
\end{align*}\]</p><p>Back to <span>$Z_i$</span>, this means that</p><p class="math-container">\[    Z_i \sim \mathcal{N}\left(0, \frac{(t_{i+1}- t_i)^3}{12}\right) = \sqrt{\frac{(t_{i+1} - t_i)^3}{12}}\mathcal{N}(0, 1).\]</p><p>For a normal variable <span>$N \sim \mathcal{N}(\mu, \sigma)$</span>, the expectation of the random variable <span>$e^N$</span> is <span>$\mathbb{E}[e^N] = e^{\mu + \sigma^2/2}$</span>. Hence,</p><p class="math-container">\[    \mathbb{E}[e^{Z_i}] = e^{((t_{i+1}- t_i)^3)/24}.\]</p><p>This is the contribution of this random variable to the mean of the exact solution. But in the implementation we actually draw from <span>$Z_i$</span>, not from <span>$e^{Z_i}$</span>.</p><p>Another way is to use the result in Section 14.2 of <a href="https://link.springer.com/book/10.1007/978-981-10-6265-0">Han &amp; Kloeden 2017</a>, which says that the the exact distribution of <span>$\int_0^\tau W_s\;\mathrm{d}s$</span> given the step <span>$\Delta W = W_\tau - W_0 = W_\tau$</span>, is</p><p class="math-container">\[\int_0^{\tau} W_s\;\mathrm{d}s \sim \frac{\tau}{2}\Delta W + \sqrt{\frac{\tau^3}{12}}\mathcal{N}(0, 1) = \frac{\tau}{2}\Delta W + \mathcal{N}\left(0, \frac{\tau^3}{12}\right).\]</p><p>Then, for the distribution of the integral over a mesh interval <span>$[t_i, t_{i+1}]$</span> when given the endpoints <span>$W_{t_i}$</span> and <span>$W_{t_{i+1}},$</span> we use that <span>$s \mapsto W_{t_i+s} - W_{t_i}$</span> is a standard Wiener process to find that</p><p class="math-container">\[\begin{align*}
\int_{t_i}^{t_{i+1}} W_s\;\mathrm{d}s &amp; = W_{t_i} + \int_{t_i}^{t_{i+1}} (W_s - W_{t_i})\;\mathrm{d}s \\
&amp; = W_{t_i}(t_{i+1} - t_i) + \int_{0}^{t_{i+1} - t_i} (W_{t_i+s} - W_{t_i})\;\mathrm{d}s \\
&amp; = W_{t_i}(t_{i+1} - t_i) + \frac{(t_{i+1} - t_i)}{2}(W_{t_{i+1}}-W_{t_{i}}) + Z_i \\
&amp; = \frac{(W_{t_{i+1}}+W_{t_{i}})}{2}(t_{i+1} - t_i) + Z_i,
\end{align*}\]</p><p>where <span>$Z_i$</span> is as above. Thus, breaking down the sum over the mesh intervals:</p><p class="math-container">\[\int_0^{t_j} W_s\;\mathrm{d}s = \sum_{i = 0}^{j-1} \int_{t_i}^{t_{i+1}} W_s\;\mathrm{d}s = \sum_{i=0}^{j-1} \left( \frac{(W_{t_{i+1}}+W_{t_{i}})}{2}(t_{i+1} - t_i) + Z_i\right).\]</p><p>In any case, once an Euler approximation is computed, along with realizations <span>$\{W_{t_i}\}_{i=0}^n$</span> of a sample path of the noise, we consider an exact sample solution given by</p><p class="math-container">\[    X_{t_j} = X_0 e^{\sum_{i = 0}^{j-1}\left(\frac{1}{2}\left(W_{t_i} + W_{t_{i+1}}\right)(t_{i+1} - t_i) + Z_i\right)},\]</p><p>for realizations <span>$Z_i$</span> drawn from a normal distribution and scaled by the standard deviation <span>$\sqrt{(t_{i+1} - t_i)^3/12}$</span>. This is implemented by computing the integral recursively, via</p><p class="math-container">\[    \begin{cases}
        I_j = I_{j-1} + \frac{1}{2}\left(W_{t_{j-1}} + W_{t_j}\right)(t_{j} - t_{j-1}) + Z_j, \\
        Z_j = \sqrt{\frac{(t_{j} - t_{j-1})^3}{12}} R_j, \\
        R_j \sim \mathcal{N}(0, 1), \\
    \end{cases}\]</p><p>with <span>$I_0 = 0$</span>, and setting</p><p class="math-container">\[  X_{t_j} = X_0 e^{I_j}.\]</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages</p><pre><code class="language-julia hljs">using Plots
using Random
using Distributions
using RODEConvergence</code></pre><p>Then we set up some variables, starting by choosing the <code>Xoshiro256++</code> pseudo-random number generator, and setting its seed for the sake of reproducibility:</p><pre><code class="language-julia hljs">rng = Xoshiro(123)</code></pre><p>We set the right hand side of the equation:</p><pre><code class="language-julia hljs">f(t, x, y, p) = y * x</code></pre><p>Next we set up the time interval and the initial distribution law for the initial value problem, which we take it to be a <a href="https://juliastats.org/Distributions.jl/latest/univariate/#Distributions.Normal">Distributions.Normal</a> random variable:</p><pre><code class="language-julia hljs">t0, tf = 0.0, 1.0
x0law = Normal()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.Normal{Float64}(μ=0.0, σ=1.0)</code></pre><p>The noise is a <a href="../../api/#RODEConvergence.WienerProcess"><code>WienerProcess</code></a> starting at <span>$y_0 = 0$</span>:</p><pre><code class="language-julia hljs">y0 = 0.0
noise = WienerProcess(t0, tf, y0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WienerProcess{Float64}(0.0, 1.0, 0.0)</code></pre><p>There is no parameter in the equation, so we just set <code>params</code> to <code>nothing</code>.</p><pre><code class="language-julia hljs">params = nothing</code></pre><p>The number of mesh points for the target solution and the approximations</p><pre><code class="language-julia hljs">ntgt = 2^16
ns = 2 .^ (4:14)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11-element Vector{Int64}:
    16
    32
    64
   128
   256
   512
  1024
  2048
  4096
  8192
 16384</code></pre><p>and for a visualization of one of the sample approximations</p><pre><code class="language-julia hljs">nsample = ns[[1, 2, 3, 4]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  16
  32
  64
 128</code></pre><p>Finally, we set up the number of samples for the Monte Carlo estimate of the strong error:</p><pre><code class="language-julia hljs">m = 200</code></pre><p>and add some information about the simulation, for the caption of the convergence figure.</p><pre><code class="language-julia hljs">info = (
    equation = &quot;\$\\mathrm{d}X_t/\\mathrm{d}t = W_t X_t\$&quot;,
    noise = &quot;a standard Wiener process noise \$\\{W_t\\}_t\$&quot;,
    ic = &quot;\$X_0 \\sim \\mathcal{N}(0, 1)\$&quot;
)</code></pre><p>The <em>target</em> solution as described above is implemented as</p><pre><code class="language-julia hljs">target_solver! = function (xt::Vector{T}, t0::T, tf::T, x0::T, f::F, yt::Vector{T}, params::Q, rng::AbstractRNG) where {T, F, Q}
    axes(xt) == axes(yt) || throw(
        DimensionMismatch(&quot;The vectors `xt` and `yt` must match indices&quot;)
    )

    n = size(xt, 1)
    dt = (tf - t0) / (n - 1)
    i1 = firstindex(xt)
    xt[i1] = x0
    integral = zero(T)
    zscale = sqrt(dt^3 / 12)
    for i in Iterators.drop(eachindex(xt, yt), 1)
        integral += (yt[i] + yt[i1]) * dt / 2 + zscale * randn(rng)
        xt[i] = x0 * exp(integral)
        i1 = i
    end
end</code></pre><p>and with that we construct the <a href="../../api/#RODEConvergence.CustomMethod"><code>CustomMethod</code></a> that solves the problem with this <code>target_solver!</code>:</p><pre><code class="language-julia hljs">target = CustomUnivariateMethod(target_solver!, rng)</code></pre><p>The method for which we want to estimate the rate of convergence is, naturally, the Euler method, denoted <a href="../../api/#RODEConvergence.RandomEuler"><code>RandomEuler</code></a>:</p><pre><code class="language-julia hljs">method = RandomEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Univariate}(Float64[])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the <a href="../../api/#RODEConvergence.ConvergenceSuite"><code>ConvergenceSuite</code></a>:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f, noise, params, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.Normal{Float64}, WienerProcess{Float64}, Nothing, typeof(Main.var&quot;Main&quot;.f), 1, 1, CustomUnivariateMethod{Main.var&quot;Main&quot;.var&quot;#1#2&quot;, Random.Xoshiro}, RandomEuler{Float64, Distributions.Univariate}}(0.0, 1.0, Distributions.Normal{Float64}(μ=0.0, σ=1.0), Main.var&quot;Main&quot;.f, WienerProcess{Float64}(0.0, 1.0, 0.0), nothing, CustomUnivariateMethod{Main.var&quot;Main&quot;.var&quot;#1#2&quot;, Random.Xoshiro}(Main.var&quot;Main&quot;.var&quot;#1#2&quot;(), Random.Xoshiro(0xfefa8d41b8f5dca5, 0xf80cc98e147960c1, 0x20e2ccc17662fc1d, 0xea7a7dcb2e787c01, 0xf4e85a418b9c4f80)), RandomEuler{Float64, Distributions.Univariate}(Float64[]), 65536, [16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384], 200, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [5.432314405525e-312, 1.0864623630396e-311, 1.6296932855267e-311, 5.180654e-318, 2.172924208014e-311, 2.716155130501e-311, 6.5188125152046e-311, 1.35807730621777e-310, 1.30375421396906e-310, 1.24943112172035e-310  …  1.0761404574469935e-308, 1.0766836883694806e-308, 1.0772269192919677e-308, 1.077770150214455e-308, 1.078313381136942e-308, 1.078856612059429e-308, 1.079399842981916e-308, 1.0799430739044033e-308, 1.0804863048268904e-308, 1.0810295357493775e-308], [6.90495306864373e-310, 3.92742505e-316, 3.92742505e-316, 3.92742505e-316, 1.0810295357493775e-308, 1.0815727666718646e-308, 1.0821159975943517e-308, 1.082659228516839e-308, 1.083202459439326e-308, 1.083745690361813e-308  …  7.13262201225604e-309, 7.138054321480913e-309, 7.143486630705784e-309, 7.148918939930655e-309, 7.154351249155526e-309, 7.159783558380398e-309, 7.16521586760527e-309, 7.17064817683014e-309, 7.17608048605501e-309, 7.18151279527988e-309], [6.90495306864136e-310, 3.3032636e-316, 3.8102714e-316, 3.3032636e-316, 0.0, 4.05766e-319, 1.35807730622e-312, 1.39113802136363e-309, 3.181697100895784e107, -4.65451068514763e214  …  3.34963465e-316, NaN, 3.66720344e-316, NaN, 6.9049516230037e-310, NaN, 3.33086173e-316, NaN, 0.0, 6.4766e-319])</code></pre><p>Then we are ready to compute the errors via <a href="../../api/#RODEConvergence.solve"><code>solve</code></a>:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  1.999815 seconds (3.37 M allocations: 354.605 MiB, 2.48% gc time, 84.00% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, suite, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{center}
        \begin{tabular}[htb]{|r|l|l|l|}
            \hline N &amp; dt &amp; error &amp; std err \\
            \hline \hline
            16 &amp; 0.0625 &amp; 0.0402 &amp; 0.00602 \\
            32 &amp; 0.0312 &amp; 0.0214 &amp; 0.00351 \\
            64 &amp; 0.0156 &amp; 0.0102 &amp; 0.00176 \\
            128 &amp; 0.00781 &amp; 0.00519 &amp; 0.000931 \\
            256 &amp; 0.00391 &amp; 0.00253 &amp; 0.000431 \\
            512 &amp; 0.00195 &amp; 0.00123 &amp; 0.000201 \\
            1024 &amp; 0.000977 &amp; 0.000621 &amp; 9.97e-5 \\
            2048 &amp; 0.000488 &amp; 0.00031 &amp; 4.93e-5 \\
            4096 &amp; 0.000244 &amp; 0.000166 &amp; 2.57e-5 \\
            8192 &amp; 0.000122 &amp; 8.22e-5 &amp; 1.33e-5 \\
            16384 &amp; 6.1e-5 &amp; 3.9e-5 &amp; 6.94e-6 \\
            \hline
        \end{tabular}
    \end{center}

    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for $\mathrm{d}X_t/\mathrm{d}t = W_t X_t$ for each mesh resolution $N$, with initial condition $X_0 \sim \mathcal{N}(0, 1)$ and a standard Wiener process noise $\{W_t\}_t$, on the time interval $I = [0.0, 1.0]$, based on $M = 200$ sample paths for each fixed time step, with the target solution calculated with $65536$ points. The order of strong convergence is estimated to be $p = 1.001$, with the 95\% confidence interval $[0.936, 1.0664]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 1.0 and 95% confidence interval (0.936, 1.07)</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We create a plot with the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt = plot(result)</code></pre><img src="039e75b6.svg" alt="Example block output"/><p>For the sake of illustration, we plot the approximations of a sample target solution:</p><pre><code class="language-julia hljs">plt = plot(suite, ns=nsample)</code></pre><img src="1dfc98cd.svg" alt="Example block output"/><p>Finally, we also visualize the noise associated with this sample solution:</p><pre><code class="language-julia hljs">plot(suite, xshow=false, yshow=true, label=&quot;Wiener noise&quot;)</code></pre><img src="58336b53.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/extras/">« Extras</a><a class="docs-footer-nextpage" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:07">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
