<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Random Fisher-KPP partial differential equation · Euler method for RODEs</title><meta name="title" content="Random Fisher-KPP partial differential equation · Euler method for RODEs"/><meta property="og:title" content="Random Fisher-KPP partial differential equation · Euler method for RODEs"/><meta property="twitter:title" content="Random Fisher-KPP partial differential equation · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/10-fisherkpp/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/10-fisherkpp/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/examples/10-fisherkpp/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../09-risk/">An actuarial risk model</a></li><li class="is-active"><a class="tocitem" href>Random Fisher-KPP partial differential equation</a><ul class="internal"><li><a class="tocitem" href="#The-equation"><span>The equation</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li></ul></li><li><a class="tocitem" href="../11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Random Fisher-KPP partial differential equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Random Fisher-KPP partial differential equation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Random-Fisher-KPP-partial-differential-equation"><a class="docs-heading-anchor" href="#Random-Fisher-KPP-partial-differential-equation">Random Fisher-KPP partial differential equation</a><a id="Random-Fisher-KPP-partial-differential-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Fisher-KPP-partial-differential-equation" title="Permalink"></a></h1><p>Here we simulate a Fisher-KPP equation with random boundary conditions, as inspired by the works of <a href="https://doi.org/10.1007/s10884-020-09847-2">Salako &amp; Shen (2020)</a> and <a href="https://doi.org/10.1214/aop/1176989813">Freidlin &amp; Wentzell (1992)</a>. The first work addresses the Fisher-KPP equation with a random reaction coefficient, while the second work considers more general reaction-diffusion equations but driven by random boundary conditions. The deterministic Fisher-KPP equations has its origins in <a href="https://doi.org/10.1111/j.1469-1809.1937.tb02153.x">Fisher (1937)</a> and <a href="https://www.bibsonomy.org/bibtex/23cfaf2cd2a49db658463fc5b115b3aa4/peter.ralph">Kolmogorov, Petrovskii &amp; Piscunov (1937)</a></p><p>We consider the Fisher-KPP equation driven by Neumann boundary conditions, with a random influx on the left end point and no flux on the right end point. The intent here is to illustrate the strong order 1 convergence rate on a nonlinear partial differential equation.</p><p>We use the method of lines (MOL), with finite differences in space, to approximate the random partial differential equation (PDE) by a system of random ODEs.</p><p>The equation is a nonlinear parabolic equation of reaction-diffusion type, modeling inhomogeneous population growth displaying wave propagation, and many other phenomena such as combustion front wave propagation, physiollogy and crystallography pattern formation, and so on. We force the system with a random incoming population on one of the boundaries of the spatial domain.</p><h2 id="The-equation"><a class="docs-heading-anchor" href="#The-equation">The equation</a><a id="The-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation" title="Permalink"></a></h2><p>The equation takes the form</p><p class="math-container">\[  \frac{\partial u}{\displaystyle \partial t} = \mu\frac{\partial^2 u}{\partial x^2} + \lambda u\left(1 - \frac{u}{u_m}\right), \quad (t, x) \in (0, \infty) \times (0, 1),\]</p><p>endowed with the boundary conditions</p><p class="math-container">\[  \frac{\partial u}{\partial x}(t, 0) = - Y_t, \quad \frac{\partial u}{\partial x}(t, 1) = 0,\]</p><p>and a given a initial condition</p><p class="math-container">\[  u(0, x) = u_0(x).\]</p><p>The unknown <span>$u(t, x)$</span> represents the density of a given quantity at time <span>$t$</span> and point <span>$x$</span>; <span>$D$</span> is a diffusivity coefficient; <span>$\lambda$</span> is a reaction, or proliferation, coefficient; and <span>$u_m$</span> is a carrying capacity density coefficient.</p><p>The random process <span>$\{Y_t\}_t,$</span> which drives the flux on the left boundary point, is taken to be a colored noise modulated by a exponentially decaying Hawkes process, representing random trains of incoming population.</p><p>This equation displays traveling wave solutions with a minimum wave speed of <span>$2 \sqrt{\lambda \mu}$</span>. We choose <span>$\lambda = 10$</span> and <span>$\mu= 0.009$</span>, so the limit traveling speed is about <span>$0.6$</span>. The carrying capacity is set to <span>$u_m = 1.0$</span>.</p><p>The initial condition is taken to be zero, <span>$u_0(x) = 0$</span>, so all the population originates from the left boundary influx.</p><p>The mass within the region <span>$0\leq x \leq 1$</span> satisfies</p><p class="math-container">\[  \frac{\mathrm{d}}{\mathrm{d} t} \int_0^1 u(t, x) \;\mathrm{d}x = \mu\int_0^1 u_{xx}(t, x) \;\mathrm{d}x + \lambda \int_0^1 u(t, x)\left(1 - \frac{u(t, x)}{u_m}\right)\;\mathrm{d}x.\]</p><p>Using the boundary conditions, we find that</p><p class="math-container">\[  \frac{\mathrm{d}}{\mathrm{d} t} \int_0^1 u(t, x) \;\mathrm{d}x = \mu Y_t  + \frac{\lambda}{u_m} \int_0^1 u(t, x)\left(u_m - u(t, x)\right)\;\mathrm{d}x,\]</p><p>which is nonnegative, provided <span>$0 \leq u \leq u_m$</span> and <span>$Y_t \geq 0$</span>.</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages:</p><pre><code class="language-julia hljs">using Plots
using Measures
using Random
using LinearAlgebra
using Distributions
using RODEConvergence
using BenchmarkTools</code></pre><p>Then we set up some variables as usual, starting with the random seed:</p><pre><code class="language-julia hljs">rng = Xoshiro(123)</code></pre><p>The time interval:</p><pre><code class="language-julia hljs">t0, tf = 0.0, 2.0</code></pre><p>The discretization in space is made with <code>l+1</code> mesh points <span>$x_j = j / l$</span>, for <span>$j = 0, \ldots, l$</span>, corresponding to <code>l</code> mesh intervals of length <span>$\Delta x = 1 / l$</span>. The points <span>$x_0 = 0$</span> and <span>$x_l = 1$</span> are the boundary points. For illustration purposes, we start by setting <code>l</code> to</p><pre><code class="language-julia hljs">l = 64</code></pre><p>Notice that for the target solution we need a very fine <em>time</em> mesh, on top of having to repeat the simulation a number of times for the Monte-Carlo estimate. This is computationally demanding for large <code>l</code>, so we choose a moderate number just for illustration purpose.</p><p>The initial mass is zero:</p><pre><code class="language-julia hljs">u₀(x) = 0.0</code></pre><p>The discretized initial condition is then</p><pre><code class="language-julia hljs">u0law = product_distribution(Tuple(Dirac(u₀(j / l)) for j in 0:l)...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.ProductDistribution{1, 0, NTuple{65, Distributions.Dirac{Float64}}, Distributions.Discrete, Float64}(
dists: (Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0))
size: (65,)
)
</code></pre><p>For the discretization of the equation we use finite differences with the classic second-order discretization of the second derivative:</p><p class="math-container">\[  \frac{\partial^2 u}{\partial x^2}(t, x_j) \approx \frac{u(t, x_{j+1}) - 2u(t, x_j) + u(t, x_{j-1})}{\Delta x^2}, \quad j = 1, \ldots, l\]</p><p>Notice this goes up to the boundary points <span>$j=0$</span> and <span>$j=l$</span>, corresponding to <span>$x=0$</span> and <span>$x=1$</span>, and depends on the &quot;ghost&quot; points <span>$x_{-1} = -\Delta x$</span> and <span>$x_{l+1} = 1 + \Delta x$</span>. These points are solved for by using the Neumann boundary conditions and a centered second-order finite difference approximation of the first derivative, namely</p><p class="math-container">\[  \frac{\partial u}{\partial x}(t, x_j) \approx \frac{u(t, x_{j+1} - u(t, x_{j-1}))}{2\Delta x},\]</p><p>on the boundary points <span>$j=0$</span> and <span>$j=l$</span>, so that</p><p class="math-container">\[  u(t, x_{-1}) = u(t, x_1) + 2Y_t \Delta x, \qquad u(t, x_{l+1}) = u(t, x_{l-1}).\]</p><p>These points are plugged into the second-order approximation of the second derivatives at the boundary points.</p><p>This yields the following in-place formulation for the right-hand side of the MOL Random ODE approximation of the Random PDE, keeping in mind that julia is 1-based, so the <code>j</code> indices are shifted up by one.</p><pre><code class="language-julia hljs">μ = 0.009
λ = 10.0
uₘ = 1.0

params = (μ, λ, uₘ)

function f!(du, t, u, y, p) # ; μ=μ, λ=λ, uₘ=uₘ)
    axes(u, 1) isa Base.OneTo || error(&quot;indexing of `x` should be Base.OneTo&quot;)

    μ = p[1]
    λ = p[2]
    uₘ = p[3]

    l = length(u) - 1
    dx = 1.0 / l
    dx² = dx ^ 2

    # interior points
    for j in 2:l
        du[j] = μ * (u[j-1] - 2u[j] + u[j+1]) / dx² + λ * u[j] * (1.0 - u[j] / uₘ)
    end

    # ghost points
    gh01 = u[2] + 2dx * max(0.0, y[1] * y[2])
    ghl1 = u[l]

    # boundary points
    du[1] = μ * ( u[2] - 2u[1] + gh01 ) / dx² + λ * u[1] * ( 1.0 - u[1] / uₘ )
    du[l+1] = μ * ( ghl1 - 2u[l+1] + u[l] ) / dx² + λ * u[l+1] * ( 1.0 - u[l+1] / uₘ )
    return nothing
end</code></pre><p>We set the parameters for the equation</p><pre><code class="language-julia hljs">μ = 0.009
λ = 10.0
uₘ = 1.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>Now we make sure this is non-allocating. We use a finer spatial mesh for testing.</p><pre><code class="language-julia hljs">xx = 0.0:0.01:1.0
u = sin.(π * xx) .^ 2
du = similar(u)
y = [0.0, 0.0]
t = 0.0
f!(du, t, u, y, params)</code></pre><p>Visualize the results</p><pre><code class="language-julia hljs">plot(xx, u, label=&quot;u&quot;)
plot!(xx, du, label=&quot;du/dt&quot;)</code></pre><img src="58998feb.svg" alt="Example block output"/><p>and check performace</p><pre><code class="language-julia hljs">@btime f!($du, $t, $u, $y, $params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  82.133 ns (0 allocations: 0 bytes)</code></pre><p>The noise is a colored Ornstein-Uhlenbeck noise truncated to non-negative values and modulated by a Hawkes process, which is implemented as two separate noises, which are combined in <code>f!</code>.</p><p>The Ornstein-Uhlenbeck is defined as follows</p><pre><code class="language-julia hljs">y0 = 0.0
τ = 0.005 # time scale
ς = √τ # large-scale diffusion
ν = 1/τ # drift
σ = ς/τ # diffusion
colored_noise = OrnsteinUhlenbeckProcess(t0, tf, y0, ν, σ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrnsteinUhlenbeckProcess{Float64}(0.0, 2.0, 0.0, 200.0, 14.14213562373095)</code></pre><p>And the exponentially-decaying Hawkes process is defined by</p><pre><code class="language-julia hljs">λ₀ = 5.0
a = 1.4
δ = 8.0
β = 0.4
θ = 1/β
dylaw = Exponential(θ)

hawkes_envelope_noise = ExponentialHawkesProcess(t0, tf, λ₀, a, δ, dylaw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ExponentialHawkesProcess{Float64, Distributions.Exponential{Float64}}(0.0, 2.0, 5.0, 1.4, 8.0, Distributions.Exponential{Float64}(θ=2.5))</code></pre><p>The are combined into the following <a href="../../api/#RODEConvergence.ProductProcess"><code>ProductProcess</code></a></p><pre><code class="language-julia hljs">noise = ProductProcess(colored_noise, hawkes_envelope_noise)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductProcess{Float64, Tuple{OrnsteinUhlenbeckProcess{Float64}, ExponentialHawkesProcess{Float64, Distributions.Exponential{Float64}}}}((OrnsteinUhlenbeckProcess{Float64}(0.0, 2.0, 0.0, 200.0, 14.14213562373095), ExponentialHawkesProcess{Float64, Distributions.Exponential{Float64}}(0.0, 2.0, 5.0, 1.4, 8.0, Distributions.Exponential{Float64}(θ=2.5))))</code></pre><p>Here is a sample path of the two noises:</p><pre><code class="language-julia hljs">tt = range(t0, tf, length=2^9+1)
yt = Matrix{Float64}(undef, 2^9+1, 2)
rand!(rng, noise, yt)</code></pre><pre><code class="language-julia hljs">plt_OUandHawkes = plot(tt, yt, label=[&quot;OU&quot; &quot;Hawkes&quot;], xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$y\$&quot;)</code></pre><img src="86817637.svg" alt="Example block output"/><p>and the modulated and truncated colored noise:</p><pre><code class="language-julia hljs">plt_noise = plot(tt, map(y -&gt; max(0.0, y[1] * y[2]), eachrow(yt)), label=&quot;noise&quot;, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$y\$&quot;)</code></pre><img src="1cba5441.svg" alt="Example block output"/><p>We also make sure drawing a noise sample path does not allocate. We use a different, and disposable, random seed, not to mess up with the reproducibility, since benchmarks can have different evaluations and samples, depending on the system itself and on the system environment:</p><pre><code class="language-julia hljs">@btime rand!($Xoshiro(), $noise, $yt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  9.197 μs (2 allocations: 144 bytes)</code></pre><p>Now that we are done with testing, we set up the mesh parameters for the convergence. For stability reasons, we let <span>$\Delta t \sim \Delta x^2$</span> and make sure that <span>$2\mu \Delta t/\Delta x^2 \leq 1.$</span> This condition follows from the Von Neumann stability analysis, by checking for discrete solution <span>$E_{j,k} = A e^{\alpha k\tau  - i \beta j h}$</span> of the error, where <span>$\tau = \Delta t$</span>, <span>$h = \Delta x$</span>, and requiring that the amplification factor at each time step is bounded by <span>$1 + \mathcal{O}(\tau).$</span></p><pre><code class="language-julia hljs">l = 512 # 2^9
u0law = product_distribution(Tuple(Dirac(u₀(j / l)) for j in 0:l)...)
ntgt = 2^18
ns = [2^5, 2^7, 2^9]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
  32
 128
 512</code></pre><pre><code class="language-julia hljs">ks = [2^6, 2^5, 2^4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 64
 32
 16</code></pre><pre><code class="language-julia hljs">@info  l ./ ks # 2^9 ./ ks = [2^3 2^4 2^5] = [8 16 32]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: [8.0, 16.0, 32.0]</code></pre><p>and make sure they meet all the requirements:</p><pre><code class="language-julia hljs">all(mod(ntgt, n) == 0 for n in ns) &amp;&amp; ntgt ≥ last(ns)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The number of simulations for the Monte-Carlo estimate of the rate of strong convergence</p><pre><code class="language-julia hljs">m = 40</code></pre><p>We then add some information about the simulation, for the caption of the convergence figure.</p><pre><code class="language-julia hljs">info = (
    equation = &quot;the Fisher-KPP equation&quot;,
    noise = &quot;Hawkes-modulated Ornstein-Uhlenbeck colored noise&quot;,
    ic = &quot;\$X_0 = 0\$&quot;
)</code></pre><p>We define the <em>target</em> solution as the Euler approximation, which is to be computed with the target number <code>ntgt</code> of mesh points, and which is also the one we want to estimate the rate of convergence, in the coarser meshes defined by <code>ns</code>.</p><pre><code class="language-julia hljs">target = RandomEuler(length(u0law))
method = RandomEuler(length(u0law))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Multivariate}([NaN, 3.3127e-320, 6.9049530685449e-310, 1.65168501e-315, 0.0, 0.0, 2.121963412e-314, 5.0e-324, 0.0, 1.317465886e-315  …  0.0, 1.65203315e-315, 0.0, 1.651254186e-315, 1.65140553e-315, 1.65202959e-315, 0.0, 0.0, 1.651254186e-315, 1.651349007e-315])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the convergence suite:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, u0law, f!, noise, params, target, method, ntgt, ns, m, ks)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.ProductDistribution{1, 0, NTuple{513, Distributions.Dirac{Float64}}, Distributions.Discrete, Float64}, ProductProcess{Float64, Tuple{OrnsteinUhlenbeckProcess{Float64}, ExponentialHawkesProcess{Float64, Distributions.Exponential{Float64}}}}, Tuple{Float64, Float64, Float64}, typeof(Main.var&quot;Main&quot;.f!), 2, 2, RandomEuler{Float64, Distributions.Multivariate}, RandomEuler{Float64, Distributions.Multivariate}}(0.0, 2.0, Distributions.ProductDistribution{1, 0, NTuple{513, Distributions.Dirac{Float64}}, Distributions.Discrete, Float64}(
dists: (Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0))
size: (513,)
)
, Main.var&quot;Main&quot;.f!, ProductProcess{Float64, Tuple{OrnsteinUhlenbeckProcess{Float64}, ExponentialHawkesProcess{Float64, Distributions.Exponential{Float64}}}}((OrnsteinUhlenbeckProcess{Float64}(0.0, 2.0, 0.0, 200.0, 14.14213562373095), ExponentialHawkesProcess{Float64, Distributions.Exponential{Float64}}(0.0, 2.0, 5.0, 1.4, 8.0, Distributions.Exponential{Float64}(θ=2.5)))), (0.009, 10.0, 1.0), RandomEuler{Float64, Distributions.Multivariate}([9.025693482338713e38, -3.8536062455651075e142, 1.3553519680461171e234, 8.122157738101038e38, 1.593872637408912e58, 1.8080694835432424e-229, -5.959349034408064e-264, 6.772325310341174e-305, 6.281724784763662e-133, 5.37189018620751e-307  …  0.0, NaN, NaN, 0.0, 8.07e-321, 9.55790466e-316, 9.56492355e-316, 0.0, 0.0, 1.40417263e-315]), RandomEuler{Float64, Distributions.Multivariate}([NaN, 3.3127e-320, 6.9049530685449e-310, 1.65168501e-315, 0.0, 0.0, 2.121963412e-314, 5.0e-324, 0.0, 1.317465886e-315  …  0.0, 1.65203315e-315, 0.0, 1.651254186e-315, 1.65140553e-315, 1.65202959e-315, 0.0, 0.0, 1.651254186e-315, 1.651349007e-315]), 262144, [32, 128, 512], 40, [64, 32, 16], [9.8094465e-316 NaN; 6.90495306864373e-310 NaN; … ; NaN 1.53098217e-316; 0.0 1.265e-321], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [1.365504877e-315 4.0e-323 … 9.4769111e-316 1.709800016e-315; 1.487406287e-315 NaN … 1.705450816e-315 1.022132573e-315; … ; 4.0e-323 NaN … 7.23113056e-316 1.84736837e-316; 7.4293742e-316 7.4665817e-316 … 1.265e-321 1.265e-321])</code></pre><p>Then we are ready to compute the errors:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> 40.618630 seconds (1.09 M allocations: 54.594 MiB, 2.07% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in <code>result.errors</code>, and a raw LaTeX table can be displayed for inclusion in the article:</p><pre><code class="language-julia hljs">table = generate_error_table(result, suite, info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{center}
        \begin{tabular}[htb]{|r|l|l|l|}
            \hline N &amp; dt &amp; error &amp; std err \\
            \hline \hline
            32 &amp; 0.0625 &amp; 132.0 &amp; 21.2 \\
            128 &amp; 0.0156 &amp; 31.5 &amp; 5.03 \\
            512 &amp; 0.00391 &amp; 6.01 &amp; 0.959 \\
            \hline
        \end{tabular}
    \end{center}

    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for the Fisher-KPP equation for each mesh resolution $N$, with initial condition $X_0 = 0$ and Hawkes-modulated Ornstein-Uhlenbeck colored noise, on the time interval $I = [0.0, 2.0]$, based on $M = 40$ sample paths for each fixed time step, with the target solution calculated with $262144$ points. The order of strong convergence is estimated to be $p = 1.116$, with the 95\% confidence interval $[0.9995, 1.2318]$.}</code></pre><p>The calculated order of convergence is given by <code>result.p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 1.1 and 95% confidence interval (0.999, 1.23)</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We create a plot with the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt_result = plot(result)</code></pre><img src="bd296cc1.svg" alt="Example block output"/><p>We also combine some plots into a single figure, for the article:</p><pre><code class="language-julia hljs">plt_combined = plot(plt_result, plt_OUandHawkes, plt_noise, layout=@layout([ a [ b; c ] ]), size=(800, 280), title=[&quot;(a) Fisher-KPP model&quot; &quot;(b) noise parts&quot; &quot;(c) noise sample path&quot;], legendfont=7, titlefont=10, bottom_margin=5mm, left_margin=5mm)</code></pre><img src="1b28f241.svg" alt="Example block output"/><p>For the sake of illustration, we plot the evolution of a sample target solution:</p><pre><code class="language-julia hljs">dt = ( tf - t0 ) / ( ntgt - 1 )

@time anim = @animate for i in 1:div(ntgt, 2^7):div(ntgt, 1)
    plot(range(0.0, 1.0, length=l+1), view(suite.xt, i, :), ylim=(0.0, 1.1), xlabel=&quot;\$x\$&quot;, ylabel=&quot;\$u\$&quot;, fill=true, title=&quot;population density at time t = $(round((i * dt), digits=3))&quot;, titlefont=10, legend=false)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  2.413475 seconds (1.09 M allocations: 68.429 MiB, 7.04% compilation time)</code></pre><img src="96d1380c.gif" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../09-risk/">« An actuarial risk model</a><a class="docs-footer-nextpage" href="../11-combined_convergences/">Combined plot »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:05">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
