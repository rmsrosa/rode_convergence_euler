<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mechanical structural under random Earthquake-like seismic disturbances · Euler method for RODEs</title><meta name="title" content="Mechanical structural under random Earthquake-like seismic disturbances · Euler method for RODEs"/><meta property="og:title" content="Mechanical structural under random Earthquake-like seismic disturbances · Euler method for RODEs"/><meta property="twitter:title" content="Mechanical structural under random Earthquake-like seismic disturbances · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/08-earthquake/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/examples/08-earthquake/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/examples/08-earthquake/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../06-popdyn/">Population dynamics with harvest</a></li><li><a class="tocitem" href="../07-toggle_switch/">A toggle-switch model for gene expression</a></li><li class="is-active"><a class="tocitem" href>Mechanical structural under random Earthquake-like seismic disturbances</a><ul class="internal"><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li></ul></li><li><a class="tocitem" href="../09-risk/">An actuarial risk model</a></li><li><a class="tocitem" href="../10-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../../noises/noiseintro/">Noises</a></li><li><a class="tocitem" href="../../noises/homlin/">Homogeneous linear Itô process noise</a></li><li><a class="tocitem" href="../../noises/fBm/">Simulating fractional Brownian motion</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Mechanical structural under random Earthquake-like seismic disturbances</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mechanical structural under random Earthquake-like seismic disturbances</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mechanical-structural-under-random-Earthquake-like-seismic-disturbances"><a class="docs-heading-anchor" href="#Mechanical-structural-under-random-Earthquake-like-seismic-disturbances">Mechanical structural under random Earthquake-like seismic disturbances</a><a id="Mechanical-structural-under-random-Earthquake-like-seismic-disturbances-1"></a><a class="docs-heading-anchor-permalink" href="#Mechanical-structural-under-random-Earthquake-like-seismic-disturbances" title="Permalink"></a></h1><p>Now we consider a mechanical structure problem under ground-shaking Earthquake-like excitations. The problem is modeled by a second-order Random ODE driven by a random disturbance in the form of a transport process. The equation is inspired by the model in <a href="https://doi.org/10.1785/BSSA0510020293">Bogdanoff, Goldberg &amp; Bernard (1961)</a> (see also [Chapter 18]{NeckelRupp2013} and {HousnerJenning1964} with this and other models).</p><p>There are a number of models for earthquake-type forcing, such as the ubiquitous Kanai-Tajimi and Clough-Penzien models, where the noise has a characteristic spectral density, determined by the mechanical properties of the ground layer. The ideia, from {Kanai1957}, is that the spectrum of the noise at bedrock is characterized by a constant pattern, while at the ground surface it is modified by the vibration property of the ground layer. This interaction between the bedrock and the ground layer is modeled as a stochastic oscillator driven by a zero-mean Gaussian white noise, and whose solution leads to a noise with a characteristic power spectrum.</p><p>Another important aspect concerns the fact that the aftershocks tend to come in clusters, with the ocurrence of an event increasing the chances for subsequent events. As such, self-exciting intensity processes have been successful in modeling the arrival times of the aftershocks (see e.g. <a href="https://doi.org/10.1088/1742-6596/855/1/012033">Pratiwi, Slamet, Saputro &amp; Respatiwulan (2017)</a>). The decaying kernel is usually an inverse power law, starting with the celebrated Omori formula <a href="https://doi.org/10.4294/jpe1952.43.1">T. Utsu, Y. Ogata &amp; R. S. Matsu&#39;ura, The centenary of the Omori formula for a decay law of aftershock activity, Journal of Physics of the Earth, Volume 43 (1995), no. 1, 1-33</a>). Exponentially decaying kernels are also used and, in this case, leads to a noise in the form of an exponentially decaying self-excited Hawkes process. The intensity, or rate, of this inhomogenous Poisson point process, for the interarrival times, is not directly related to the magnitude of the aftershocks, so this process should be coupled with another process for the magnitude of each shock.</p><p>We follow, however, the Bogdanoff-Goldberg-Bernard model, which takes the form of a transport process noise. We chose the later so we can illustrate the improved convergence for such type of noise, complementing the other examples. This model is described in more details shortly. Let us introduce first the model for the vibrations of the mechanical structure.</p><p>A single-storey building is considered, with its ground floor centered at position <span>$M_t$</span> and its ceiling at position <span>$M_t + X_t$</span>. The random process <span>$X_t$</span> refers to the motion relative to the ground. The ground motion <span>$M_t$</span> affects the motion of the relative displacement <span>$X_t$</span> as an excitation force proportional to the ground acceleration <span>$\ddot M_t$</span>. The damping and elastic forces are in effect within the structure. In this framework, the equation of motion for the relative displacement <span>$X_t$</span> of the ceiling of the single storey building takes the following form.</p><p class="math-container">\[  \ddot X_t + 2\zeta_0\omega_0\dot X_t + \omega_0^2 X_t = - \ddot M_t.\]</p><p>where <span>$\zeta_0$</span> and <span>$\omega_0$</span> are damping and elastic model parameters depending on the structure.</p><p>For the numerical simulations, the second-order equation is written as a system of first-order equations:</p><p class="math-container">\[  \begin{cases}
      \dot X_t = V_t, \\
      \dot V_t = - \omega_0^2 X_t - 2\zeta_0\omega_0 X_t - Y_t,
  \end{cases}\]</p><p>where <span>$\{V_t\}_t$</span> is the random velocity of the celing relative to the ground and where <span>$\{Y_t\}_t$</span> is the stochastic noise excitation term given as the ground acceleration, <span>$Y_t = \ddot M_t$</span>, generated by an Earthquake and its aftershocks, or any other type of ground motion.</p><p>The structure is originally at rest, so we have the initial conditions</p><p class="math-container">\[X_0 = 0, \quad V_0 = \dot X_0 = 0.\]</p><p>In the Bogdanoff-Goldberg-Bernard model \cite{BogdanoffGoldbergBernard1961}, the excitation <span>$\ddot M_t$</span> is made of a composition of oscillating signals <span>$a_j t e^{-\delta_j t}\cos(\omega_j t + \theta_j)$</span> with random frequencies <span>$\omega_j$</span>, modulated by a linear attack rate <span>$a_j t$</span> followed by an exponential decay <span>$e^{-\delta_j t}$</span>.</p><p>In order to simulate the start of the first shock-wave and the subsequent aftershocks, we modify this model sligthly to be a combination of such terms but at different incidence times. We also remove the attack rate from the excitation to obtain a rougher instantaneous, discontinuous excitation, which is connected with a square power attact rate for the displacement itself. Finally, for simulation purposes, we model directly the displacement <span>$M_t$</span> and compute the associated excitation <span>$\ddot M_t$</span>, but in such a way that the ground-motion excitation follows essentially the proposed type of signal.</p><p>Thus, with this framework in mind, we model the ground displacement as a transport process composed of a series of time-translations of a square-power ``attack&quot; front, with an exponentially decaying tail and an oscillating background wave:</p><p class="math-container">\[   M_t = \sum_{i=1}^k \gamma_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)),\]</p><p>where <span>$k\in \mathbb{N}$</span> is given, <span>$(t-\tau_i)_+ = \max\{0, t - \tau_i\}$</span> is the positive part of the function, and the parameters <span>$\gamma_i,$</span> <span>$\tau_i,$</span> <span>$\delta_i,$</span> and <span>$\omega_i$</span> are all random variables, with <span>$\tau_i$</span> being exponentially distributed, and <span>$\gamma_i$</span>, <span>$\delta_i$</span>, and <span>$\omega_i$</span> being uniformly distributed, each with different support values, and all of them independent of each other. Each front (disregarding the oscillatory part) peaks at <span>$t = \tau_i + 2/\delta_i,$</span> with peak value approximately <span>$\gamma / 2\delta^2.$</span></p><p>The excitation itself becomes</p><p class="math-container">\[\begin{align*}
   \ddot M(t) = \; &amp; \sum_{i=1}^k \gamma_i e^{-\delta_i (t - \tau_i)} \bigg\{ \left(2 H(t - \tau_i) - 4\delta_i(t - \tau_i)_+ + (\delta_i^2 - \omega_i^2) (t - \tau_i)_+^2 \right) \cos(\omega_i (t - \tau_i)) \\
      &amp;  \hspace{2in} + \left( -4\omega_i (t - \tau_i)_+ + 2\delta_i\omega_i (t - \tau_i)_+^2 \right) \sin(\omega_i (t - \tau_i)) \bigg\}
\end{align*}\]</p><p>where <span>$H = H(s)$</span> is the Heaviside function, where, for definiteness, we set <span>$H(s) = 1,$</span> for <span>$s \geq 1,$</span> and <span>$H(s) = 0$</span>, for <span>$s &lt; 0$</span>.</p><p>More specifically, for the numerical simulations, we use <span>$\zeta_0 = 0.6$</span> and <span>$\omega_0 = 15\,\texttt{rad}/\texttt{s}$</span> as the structural parameters. We set <span>$T = 2.0,$</span> as the final time. For the transport process, we set <span>$k=8$</span> and define the random parameters as</p><p class="math-container">\[   \begin{align*}
       \tau_i &amp; \sim \textrm{Exponential}(1/2) \\
       \gamma_i &amp; \sim \textrm{Unif}(16, 32), \\
       \delta_i &amp; \sim \textrm{Unif}(12, 16), \\
       \omega_i &amp; \sim \textrm{Unif}(16\pi, 32\pi).
    \end{align*}\]</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><h3 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h3><p>First we load the necessary packages:</p><pre><code class="language-julia hljs">using JLD2
using Plots
using Measures
using Random
using LinearAlgebra
using Distributions
using RODEConvergence</code></pre><p>Then we set up some variables, starting with the random seed, for reproducibility of the pseudo-random number sequence generator:</p><pre><code class="language-julia hljs">rng = Xoshiro(123)</code></pre><p>We define the evolution law for the displacement <span>$X_t$</span> driven by a noise <span>$Y_t$</span>. Since it is a system of equations, we use the in-place formulation. Notice the noise is a product of the background colored noise <code>y[1]</code> and the envelope noise <code>y[2]</code>. The parameters are hard-coded for simplicity.</p><pre><code class="language-julia hljs">ζ₀ = 0.6
ω₀ = 15.0

params = (ζ₀, ω₀)

function f!(dx, t, x, y, p)
    ζ₀ = p[1]
    ω₀ = p[2]
    dx[1] = x[2]
    dx[2] = - 2 * ζ₀ * ω₀ * x[2] - ω₀ ^ 2 * x[1] - y
    return dx
end</code></pre><p>The time interval is defined by the following end points:</p><pre><code class="language-julia hljs">t0, tf = 0.0, 2.0</code></pre><p>The structure is initially at rest, so the probability law is a vectorial product of two Dirac delta distributions, in <span>$\mathbb{R}^2$</span>:</p><pre><code class="language-julia hljs">x0law = product_distribution(Dirac(0.0), Dirac(0.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.ProductDistribution{1, 0, Tuple{Distributions.Dirac{Float64}, Distributions.Dirac{Float64}}, Distributions.Discrete, Float64}(dists=(Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0)), size=(2,))</code></pre><p>As described above, we assume the ground motion is an additive combination of translated exponentially decaying wavefronts of the form</p><p class="math-container">\[  m_i(t) = \gamma_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)),\]</p><p>where <span>$(t - \tau_i)_+ = \max\{0, t - \tau_i\}$</span>, i.e. it vanishes for <span>$t \leq \tau_i$</span> and is simply <span>$(t - \tau_i)$</span> for <span>$t\geq \tau_i$</span>. The associated noise is a combination of the second derivatives <span>$\ddot m_i(t)$</span>, which has jump discontinuities. Indeed, we have the ground velocities</p><p class="math-container">\[  \begin{align*}
  \dot m_i(t) = \; &amp; 2\gamma_i (t - \tau_i)_+ e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
      &amp; -\delta_i\gamma_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
      &amp; -\omega_i\gamma_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\sin(\omega_i (t - \tau_i)) \\
    = \; &amp; \gamma_i e^{-\delta_i (t - \tau_i)} \left\{ \left(2(t - \tau_i)_+ - \delta_i (t - \tau_i)_+^2 \right) \cos(\omega_i (t - \tau_i)) - \omega_i (t - \tau_i)_+^2 \sin(\omega_i (t - \tau_i)) \right\}
  \end{align*}\]</p><p>and the ground accelerations</p><p class="math-container">\[  \begin{align*}
  \ddot m_i(t) = \; &amp; 2\gamma_i H(t - \tau_i) e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
      &amp; - 2\gamma_i \delta_i (t - \tau_i)_+ e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
      &amp; - 2\gamma_i \omega_i (t - \tau_i)_+ e^{-\delta_i (t - \tau_i)}\sin(\omega_i (t - \tau_i)) \\
      &amp; - 2\delta_i\gamma_i (t - \tau_i)_+ e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
      &amp; +\delta_i^2\gamma_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
      &amp; +\delta_i\gamma_i\omega_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\sin(\omega_i (t - \tau_i)) \\
      &amp; -2\omega_i\gamma_i (t - \tau_i)_+ e^{-\delta_i (t - \tau_i)}\sin(\omega_i (t - \tau_i)) \\
      &amp; +\omega_i\gamma_i\delta_i (t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\sin(\omega_i (t - \tau_i)) \\
      &amp; -\omega_i^2\gamma_i(t - \tau_i)_+^2 e^{-\delta_i (t - \tau_i)}\cos(\omega_i (t - \tau_i)) \\
    = \; &amp; \gamma_i e^{-\delta_i (t - \tau_i)} \bigg\{ \left(2 H(t - \tau_i) - 4\delta_i(t - \tau_i)_+ + (\delta_i^2 - \omega_i^2) (t - \tau_i)_+^2 \right) \cos(\omega_i (t - \tau_i)) \\
      &amp;  \hspace{2in} + \left( -4\omega_i (t - \tau_i)_+ + 2\delta_i\omega_i (t - \tau_i)_+^2 \right) \sin(\omega_i (t - \tau_i)) \bigg\}
  \end{align*}\]</p><p>where <span>$H=H(s)$</span> is the Heaviside function, where, for definiteness, we set <span>$H(s) = 1,$</span> for <span>$s \geq 1,$</span> and <span>$H(s) = 0$</span>, for <span>$s &lt; 0$</span>.</p><p>We implement these functions as</p><pre><code class="language-julia hljs">function gm(t::T, τ::T, γ::T, α::T, ω::T) where {T}
    tshift = max(zero(T), t - τ)
    m = γ * tshift ^2 * exp( -α * tshift ) * cos( ω * tshift )
    return m
end

function dgm(t::T, τ::T, γ::T, δ::T, ω::T) where {T}
    tshift₊ = max(zero(T), t - τ)
    tshift₊² = tshift₊ ^ 2
    expδt₊ = exp( -δ * tshift₊ )
    sinωt₊, cosωt₊ = sincos(ω * tshift₊)
    ṁ = γ * expδt₊ * ( ( 2tshift₊ - δ * tshift₊² ) * cosωt₊ - ω * tshift₊²  * sinωt₊ )
    return ṁ
end

function ddgm(t::T, τ::T, γ::T, δ::T, ω::T) where {T}
    h = convert(T, t ≥ τ)
    tshift₊ = ( t - τ ) * h
    tshift₊² = tshift₊ ^ 2
    expδt₊ = exp( -δ * tshift₊ )
    sinωt₊, cosωt₊ = sincos(ω * tshift₊)
    m̈ = γ * expδt₊ * ( ( 2h + ( δ^2 - ω^2 ) * tshift₊² - 4δ * tshift₊) * cosωt₊ + ( -4ω * tshift₊ + 2δ * ω * tshift₊² ) * sinωt₊ )
    return m̈
end</code></pre><p>Let us visualize a cooked up example of ground motion with two components</p><pre><code class="language-julia hljs">tt = range(0.0, 2.0, length=2^9)
dt = Float64(tt.step)

τ₁ = 0.2
γ₁ = 4.0
δ₁ = 12.0
ω₁ = 24π
τ₂ = 0.8
γ₂ = 2.0
δ₂ = 16.0
ω₂ = 32π

mt = gm.(tt, τ₁, γ₁, δ₁, ω₁) .+ gm.(tt, τ₂, γ₂, δ₂, ω₂)

dmt = dgm.(tt, τ₁, γ₁, δ₁, ω₁) .+ dgm.(tt, τ₂, γ₂, δ₂, ω₂)

ddmt = ddgm.(tt, τ₁, γ₁, δ₁, ω₁) .+ ddgm.(tt, τ₂, γ₂, δ₂, ω₂)

plt1 = plot(tt, mt, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$M_t\$&quot;)
plt2 = plot(tt, dmt, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$\\dot{M}_t\$&quot;)
plt3 = plot(tt, ddmt, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$\\ddot{M}_t\$&quot;)
plot(plt1, plt2, plt3, layout=(3, 1), legend=false)</code></pre><img src="40ba3fd6.svg" alt="Example block output"/><p>We also numerically integrate the acceleration and the velocity and compare them against the velocity and the position, to make sure we implemented the derivatives correctly.</p><pre><code class="language-julia hljs">mt2 = accumulate(+, dmt) * dt
dmt2 = accumulate(+, ddmt) * dt

maximum(abs, mt2 - mt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0021883525238117346</code></pre><p>Notice this is of the order of the time step</p><pre><code class="language-julia hljs">dt</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.003913894324853229</code></pre><p>The absolute error for the derivative is high, though, because the frequency is relatively high</p><pre><code class="language-julia hljs">maximum(abs, dmt2 - dmt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.18019629674111726</code></pre><p>The relative errors, though, are both modest, considering the low order integration method used here.</p><pre><code class="language-julia hljs">maximum(abs, (mt2 - mt)) / maximum(abs, mt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.14617452413240845</code></pre><pre><code class="language-julia hljs">maximum(abs, (dmt2 - dmt)) / maximum(abs, dmt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.16123422232157686</code></pre><p>Let us now illustrate a sample path with the laws used for the random variables and the associated transport process.</p><pre><code class="language-julia hljs">τlaw = Exponential(tf/4)
γlaw = Uniform(16.0, 32.0)
δlaw = Uniform(12.0, 16.0)
ωlaw = Uniform(16π, 32π)

ylaw = product_distribution(τlaw, γlaw, δlaw, ωlaw)

nr = 8
g(t, r) = mapreduce(ri -&gt; ddgm(t, ri[1], ri[2], ri[3], ri[4]), +,  eachcol(r))
noise = TransportProcess(t0, tf, ylaw, g, nr)</code></pre><pre><code class="language-julia hljs">n = 2^12
tt = range(t0, tf, length=n)
yt = Vector{Float64}(undef, n)</code></pre><p>Sample ground acceleration</p><pre><code class="language-julia hljs">rand!(rng, noise, yt)</code></pre><p>Associated ground motion <span>$m_t$</span>:</p><pre><code class="language-julia hljs">mt = [mapreduce(ri -&gt; gm(t, ri[1], ri[2], ri[3], ri[4]), +,  eachcol(noise.rv)) for t in range(t0, tf, length=length(yt))]</code></pre><p>Associated ground velocity</p><pre><code class="language-julia hljs">dmt = [mapreduce(ri -&gt; dgm(t, ri[1], ri[2], ri[3], ri[4]), +,  eachcol(noise.rv)) for t in range(t0, tf, length=length(yt))]</code></pre><p>Visualization</p><pre><code class="language-julia hljs">plt1 = plot(tt, mt, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$M_t\$&quot;, label=nothing)
plt2 = plot(tt, dmt, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$\\dot{M}_t\$&quot;, label=nothing)
plt3 = plot(tt, yt, xlabel=&quot;\$t\$&quot;, ylabel=&quot;\$\\ddot{M}_t\$&quot;, label=nothing)
plt_ground = plot(plt1, plt2, plt3, layout = (3, 1))</code></pre><img src="2f911d09.svg" alt="Example block output"/><p>Now we are ready to check the order of convergence. We set the target resolution, the convergence test resolutions, the sample convergence resolutions, and the number of sample trajectories for the Monte-Carlo approximation of the strong error.</p><pre><code class="language-julia hljs">ntgt = 2^18
ns = 2 .^ (6:9)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
  64
 128
 256
 512</code></pre><p>The number of simulations for the Monte Carlo estimate is set to</p><pre><code class="language-julia hljs">m = 100</code></pre><p>We add some information about the simulation, for the caption of the convergence figure.</p><pre><code class="language-julia hljs">info = (
    equation = &quot;mechanical structure model under ground-shaking random excitations&quot;,
    noise = &quot;transport process noise&quot;,
    ic = &quot;\$X_0 = \\mathbf{0}\$&quot;
)</code></pre><p>We define the <em>target</em> solution as the Euler approximation, which is to be computed with the target number <code>ntgt</code> of mesh points, and which is also the one we want to estimate the rate of convergence, in the coarser meshes defined by <code>ns</code>.</p><pre><code class="language-julia hljs">target = RandomEuler(length(x0law))
method = RandomEuler(length(x0law))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomEuler{Float64, Distributions.Multivariate}([6.9048463696395e-310, 6.9048463696411e-310])</code></pre><h3 id="Order-of-convergence"><a class="docs-heading-anchor" href="#Order-of-convergence">Order of convergence</a><a id="Order-of-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-convergence" title="Permalink"></a></h3><p>With all the parameters set up, we build the convergence suites for each noise:</p><pre><code class="language-julia hljs">suite = ConvergenceSuite(t0, tf, x0law, f!, noise, params, target, method, ntgt, ns, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConvergenceSuite{Float64, Distributions.ProductDistribution{1, 0, Tuple{Distributions.Dirac{Float64}, Distributions.Dirac{Float64}}, Distributions.Discrete, Float64}, TransportProcess{Float64, typeof(Main.var&quot;Main&quot;.g), Distributions.ProductDistribution{1, 0, Tuple{Distributions.Exponential{Float64}, Distributions.Uniform{Float64}, Distributions.Uniform{Float64}, Distributions.Uniform{Float64}}, Distributions.Continuous, Float64}, 2}, Tuple{Float64, Float64}, typeof(Main.var&quot;Main&quot;.f!), 1, 2, RandomEuler{Float64, Distributions.Multivariate}, RandomEuler{Float64, Distributions.Multivariate}}(0.0, 2.0, Distributions.ProductDistribution{1, 0, Tuple{Distributions.Dirac{Float64}, Distributions.Dirac{Float64}}, Distributions.Discrete, Float64}(dists=(Distributions.Dirac{Float64}(value=0.0), Distributions.Dirac{Float64}(value=0.0)), size=(2,)), Main.var&quot;Main&quot;.f!, TransportProcess{Float64, typeof(Main.var&quot;Main&quot;.g), Distributions.ProductDistribution{1, 0, Tuple{Distributions.Exponential{Float64}, Distributions.Uniform{Float64}, Distributions.Uniform{Float64}, Distributions.Uniform{Float64}}, Distributions.Continuous, Float64}, 2}(0.0, 2.0, Distributions.ProductDistribution{1, 0, Tuple{Distributions.Exponential{Float64}, Distributions.Uniform{Float64}, Distributions.Uniform{Float64}, Distributions.Uniform{Float64}}, Distributions.Continuous, Float64}(
dists: (Distributions.Exponential{Float64}(θ=0.5), Distributions.Uniform{Float64}(a=16.0, b=32.0), Distributions.Uniform{Float64}(a=12.0, b=16.0), Distributions.Uniform{Float64}(a=50.26548245743669, b=100.53096491487338))
size: (4,)
)
, Main.var&quot;Main&quot;.g, [0.5878858418174236 0.31741332218602036 … 0.03145263265940917 0.05419377303844719; 25.388908119253575 22.249412406901506 … 18.11109972063199 27.418174759779326; 15.563514792371125 12.179272020069964 … 12.353164076529113 12.82369963794684; 59.861499788323314 97.1809357456579 … 66.02395823794512 54.817080413926014]), (0.6, 15.0), RandomEuler{Float64, Distributions.Multivariate}([0.0, 1.0]), RandomEuler{Float64, Distributions.Multivariate}([6.9048463696395e-310, 6.9048463696411e-310]), 262144, [64, 128, 256, 512], 100, [1, 1, 1, 1], [1.639309684e-315, 2.121995791e-314, 1.63930834e-315, 2.121995791e-314, 1.639239804e-315, 2.121995791e-314, NaN, NaN, 1.639239063e-315, 8.487983164e-314  …  -0.00022172967425461096, -0.00016311236200960015, 5.855830534192854e-5, -0.0001434423357047313, -0.00020685889001695752, -0.00022254054451146542, -0.00019359068945515122, -7.892233507269893e-5, -0.00016100424516924517, -0.0001617054616658484], [2.214678298387844 -0.6781142832963081; 0.0 0.5832730222644963; … ; -0.08455734652654029 0.5284302362191173; -0.20450954496226517 0.0], [6.9049530686311e-310 NaN; 6.9049530686311e-310 NaN; … ; 5.0e-324 3.8e-322; 5.8e-322 6.8024448e-316])</code></pre><p>Then we are ready to compute the errors:</p><pre><code class="language-julia hljs">@time result = solve(rng, suite)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  4.983936 seconds (652.10 k allocations: 32.330 MiB, 12.90% compilation time)</code></pre><p>The computed strong error for each resolution in <code>ns</code> is stored in field <code>errors</code>, and raw LaTeX tables can be displayed for inclusion in the article:</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">    \begin{center}
        \begin{tabular}[htb]{|r|l|l|l|}
            \hline N &amp; dt &amp; error &amp; std err \\
            \hline \hline
            64 &amp; 0.0312 &amp; 9.27 &amp; 0.721 \\
            128 &amp; 0.0156 &amp; 3.66 &amp; 0.308 \\
            256 &amp; 0.00781 &amp; 1.75 &amp; 0.142 \\
            512 &amp; 0.00391 &amp; 0.838 &amp; 0.0672 \\
            \hline
        \end{tabular}
    \end{center}

    \bigskip

    \caption{Mesh points (N), time steps (dt), strong error (error), and standard error (std err) of the Euler method for mechanical structure model under ground-shaking random excitations for each mesh resolution $N$, with initial condition $X_0 = \mathbf{0}$ and transport process noise, on the time interval $I = [0.0, 2.0]$, based on $M = 100$ sample paths for each fixed time step, with the target solution calculated with $262144$ points. The order of strong convergence is estimated to be $p = 1.147$, with the 95\% confidence interval $[1.0595, 1.2341]$.}</code></pre><p>The calculated order of convergence is given by field <code>p</code>:</p><pre><code class="language-julia hljs">println(&quot;Order of convergence `C Δtᵖ` with p = $(round(result.p, sigdigits=2)) and 95% confidence interval ($(round(result.pmin, sigdigits=3)), $(round(result.pmax, sigdigits=3)))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Order of convergence `C Δtᵖ` with p = 1.1 and 95% confidence interval (1.06, 1.23)</code></pre><pre><code class="language-julia hljs"># save to docs/build/</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>We create plots with the rate of convergence with the help of a plot recipe for <code>ConvergenceResult</code>:</p><pre><code class="language-julia hljs">plt_result = plot(result)</code></pre><img src="cff75e73.svg" alt="Example block output"/><p>For the sake of illustration, we plot a sample of an approximation of a target solution, in each case:</p><pre><code class="language-julia hljs">nsample = ns[[1, 2, 3]]
plt_sample = plot(suite, ns=nsample)</code></pre><img src="72624f77.svg" alt="Example block output"/><p>We also combine some plots into a single figure, to summarize the results.</p><pre><code class="language-julia hljs">plt_combined = plot(plt_result, plt_sample, plt1, plt2, plt3, layout=@layout([[a; b] [c; d; e]]), size=(800, 480), title=[&quot;(a) seismic model&quot; &quot;(b) sample path&quot; &quot;(c) sample ground motion&quot; &quot;(d) sample ground velocity&quot; &quot;(e) sample ground acceleration&quot;], legendfont=7, titlefont=10, bottom_margin=5mm, left_margin=5mm)</code></pre><img src="48e9a548.svg" alt="Example block output"/><p>We finally draw an animation of the motion of the single-storey building driven by the transport-modulated noise.</p><pre><code class="language-julia hljs">dt = ( tf - t0 ) / ( ntgt - 1 )
mt = [mapreduce(ri -&gt; gm(t, ri[1], ri[2], ri[3], ri[4]), +,  eachcol(noise.rv)) for t in range(t0, tf, length=ntgt)]

@time anim = @animate for i in 1:div(ntgt, 2^9):div(ntgt, 1)
    ceiling = mt[i] + suite.xt[i, 1]
    height = 3.0
    halfwidth = 2.0
    aspectfactor = (4/6) * 4halfwidth / height
    plot([mt[i] - halfwidth; ceiling - halfwidth; ceiling + halfwidth; mt[i] + halfwidth], [0.0; height; height; 0.0], xlim = (-2halfwidth, 2halfwidth), ylim=(0.0, aspectfactor * height), xlabel=&quot;\$\\mathrm{displacement}\$&quot;, ylabel=&quot;\$\\textrm{height}\$&quot;, fill=true, title=&quot;Building at time t = $(round((i * dt), digits=3))&quot;, titlefont=10, legend=false)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  8.772539 seconds (3.81 M allocations: 217.907 MiB, 0.32% gc time, 3.26% compilation time)</code></pre><img src="09cc80ca.gif" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../07-toggle_switch/">« A toggle-switch model for gene expression</a><a class="docs-footer-nextpage" href="../09-risk/">An actuarial risk model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:05">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
