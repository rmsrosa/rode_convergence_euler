<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulating fractional Brownian motion · Euler method for RODEs</title><meta name="title" content="Simulating fractional Brownian motion · Euler method for RODEs"/><meta property="og:title" content="Simulating fractional Brownian motion · Euler method for RODEs"/><meta property="twitter:title" content="Simulating fractional Brownian motion · Euler method for RODEs"/><meta name="description" content="Documentation for Euler method for RODEs."/><meta property="og:description" content="Documentation for Euler method for RODEs."/><meta property="twitter:description" content="Documentation for Euler method for RODEs."/><meta property="og:url" content="https://github.com/rmsrosa/rode_convergence_euler/noises/fBm/"/><meta property="twitter:url" content="https://github.com/rmsrosa/rode_convergence_euler/noises/fBm/"/><link rel="canonical" href="https://github.com/rmsrosa/rode_convergence_euler/noises/fBm/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Euler method for RODEs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/results/">Main results</a></li><li><a class="tocitem" href="../../theory/idea/">Main idea</a></li><li><a class="tocitem" href="../../theory/extras/">Extras</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic Linear RODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/01-wiener_linearhomogeneous/">Homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../../examples/02-wiener_linearnonhomogeneous/">Non-homogenous linear RODE with a Wiener process noise coefficient</a></li><li><a class="tocitem" href="../../examples/03-sin_gBm_linearhomogeneous/">Homogenous linear RODE with the sine of a Geometric Brownian motion coefficient</a></li></ul></li><li><a class="tocitem" href="../../examples/04-allnoises/">Linear system with all implemented noises</a></li><li><a class="tocitem" href="../../examples/05-fBm_linear/">Linear RODE with fractional Brownian motion</a></li><li><a class="tocitem" href="../../examples/06-popdyn/">Population dynamics with harvest</a></li><li><a class="tocitem" href="../../examples/07-toggle_switch/">A toggle-switch model for gene expression</a></li><li><a class="tocitem" href="../../examples/08-earthquake/">Mechanical structural under random Earthquake-like seismic disturbances</a></li><li><a class="tocitem" href="../../examples/09-risk/">An actuarial risk model</a></li><li><a class="tocitem" href="../../examples/10-fisherkpp/">Random Fisher-KPP partial differential equation</a></li><li><a class="tocitem" href="../../examples/11-combined_convergences/">Combined plot</a></li></ul></li><li><span class="tocitem">Noises</span><ul><li><a class="tocitem" href="../noiseintro/">Noises</a></li><li><a class="tocitem" href="../homlin/">Homogeneous linear Itô process noise</a></li><li class="is-active"><a class="tocitem" href>Simulating fractional Brownian motion</a><ul class="internal"><li><a class="tocitem" href="#Loading-the-packages"><span>Loading the packages</span></a></li><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Plotting-some-sample-paths"><span>Plotting some sample paths</span></a></li><li><a class="tocitem" href="#Checking-some-basic-statistics"><span>Checking some basic statistics</span></a></li><li><a class="tocitem" href="#Checking-the-probability-distribution-function"><span>Checking the probability distribution function</span></a></li><li><a class="tocitem" href="#Checking-the-covariance"><span>Checking the covariance</span></a></li><li><a class="tocitem" href="#Benchmark"><span>Benchmark</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Noises</a></li><li class="is-active"><a href>Simulating fractional Brownian motion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulating fractional Brownian motion</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rmsrosa/rode_convergence_euler" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulating-fractional-Brownian-motion"><a class="docs-heading-anchor" href="#Simulating-fractional-Brownian-motion">Simulating fractional Brownian motion</a><a id="Simulating-fractional-Brownian-motion-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-fractional-Brownian-motion" title="Permalink"></a></h1><p>We&#39;ve implemented the Davies-Harte method for simulating exact sample paths of a fractional Brownian motion <span>$\{B_H(t)\}_{0\leq t \leq T}$</span> with Hurst parameter <span>$0 &lt; H &lt; 1$</span>. There are a number of methods to simulate exact sample paths, such as the Cholesky method, which is of order <span>$O(N^3)$</span>, and the Hosking method, which is <span>$O(N^2)$</span>. These are too expensive for our needs, since we plan to build lots of sample paths with a million points. So we chose to implement the Davies-Harte method, which uses fast fourier transform (FFTs) to achieve <span>$O(N\log N)$</span>. For that, we rely on <a href="https://github.com/JuliaMath/FFTW.jl">FFTW.jl</a>, which has the julia bindings to the <a href="http://www.fftw.org">FFTW</a> library.</p><p>The point in this section is to illustrate the use of the implemented method and to do some simple sanity checks to make sure our implementation is correct.</p><h2 id="Loading-the-packages"><a class="docs-heading-anchor" href="#Loading-the-packages">Loading the packages</a><a id="Loading-the-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-packages" title="Permalink"></a></h2><p>We start by loading the necessary packages:</p><pre><code class="language-julia hljs">using Random
using Distributions
using Statistics
using BenchmarkTools
using FFTW
using LinearAlgebra
using Plots
using RODEConvergence</code></pre><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>We fix the initial condition <code>y0</code> and the initial and final times <code>t0</code> and <code>tf</code> of the time interval of the desired fractional Brownian motion process. We also fix the size <span>$N$</span> of the sample paths. The sample paths will be generated for a set of <code>n</code> times uniformly distributed within the time interval from <code>t0</code> to <code>tf</code>, which yields a time mesh which we define as <code>tt</code>:</p><pre><code class="language-julia hljs">y0 = 0.0
t0 = 0.0
tf = 2.0
n = 2^9
tt = range(t0, tf, length=n+1)</code></pre><p>We also choose a few values of the Hurst parameter for the tests, one within <span>$0 &lt; H &lt; 1/2$</span>, one exactly <span>$H = 1/2$</span> corresponding to the standard Brownian motion process, and one within <span>$1/2 &lt; H &lt; 1.$</span></p><pre><code class="language-julia hljs">Hs = (0.2, 0.5, 0.8)</code></pre><p>With this setup, we create the corresponding fractional Brownian motion processes:</p><pre><code class="language-julia hljs">noise = Dict(H =&gt; FractionalBrownianMotionProcess(t0, tf, y0, H, n) for H in Hs)</code></pre><p>This <code>noise</code> is a <code>Dict</code> with the keys being the chosen Hurst parameters and with each <code>noise[H]</code> being a fractional Brownian noise sampler with the corresponding <code>H</code> in <code>Hs</code>. With each sampler, we draw a sample path with <code>rand!(rng, noise[H], Yt)</code>, with a random number generator <code>rng</code> and a vector of floats <code>Yt</code> of size <code>N</code>, so that this sampling fills up the pre-allocated vector <code>Yt</code> with a sample path. For that, we set up the <code>rng</code>, used for reproducibility, and create the vector <code>Yt</code>.</p><pre><code class="language-julia hljs">rng = Xoshiro(123)
yt = Vector{Float64}(undef, n+1)</code></pre><h2 id="Plotting-some-sample-paths"><a class="docs-heading-anchor" href="#Plotting-some-sample-paths">Plotting some sample paths</a><a id="Plotting-some-sample-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-some-sample-paths" title="Permalink"></a></h2><p>Here we generate and plot a few sample paths with the different Hurst parameters.</p><p>First with a Hurst parameter within the range <span>$1/2 &lt; H &lt; 1$</span>.</p><pre><code class="language-julia hljs">H = Hs[3]

plt = plot(title=&quot;Sample paths of fractional Brownian motion of length $n with Hurst parameter H=$H&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;W&quot;, legend=nothing, size=(800, 400))
for _ in 1:3
    rand!(rng, noise[H], yt)
    plot!(plt, tt, yt)
end
plt</code></pre><img src="5ab24f1a.svg" alt="Example block output"/><p>Now with <span>$H=1/2$</span>, which yields a standard Brownian motion.</p><pre><code class="language-julia hljs">H = Hs[2]

plt = plot(title=&quot;Sample paths of fractional Brownian motion of length $n with Hurst parameter H=$H&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;W&quot;, legend=nothing, size=(800, 400))
for _ in 1:3
    rand!(rng, noise[H], yt)
    plot!(plt, tt, yt)
end
plt</code></pre><img src="0834d585.svg" alt="Example block output"/><p>Finally a rougher path with <span>$0 &lt; H &lt; 1/2$</span>.</p><pre><code class="language-julia hljs">H = Hs[1]

plt = plot(title=&quot;Sample paths of fractional Brownian motion of length $n with Hurst parameter H=$H&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;W&quot;, legend=nothing, size=(800, 400))
for _ in 1:3
    rand!(rng, noise[H], yt)
    plot!(plt, tt, yt)
end
plt</code></pre><img src="41fdde59.svg" alt="Example block output"/><h2 id="Checking-some-basic-statistics"><a class="docs-heading-anchor" href="#Checking-some-basic-statistics">Checking some basic statistics</a><a id="Checking-some-basic-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-some-basic-statistics" title="Permalink"></a></h2><p>Now we simulate a bunch of sample paths and check their statistics. We start by defining how much is &quot;a bunch&quot;:</p><pre><code class="language-julia hljs">m = 200</code></pre><p>Now we generate the sets of sample paths for each Hurst parameter.</p><pre><code class="language-julia hljs">W = Dict(H =&gt; Matrix{Float64}(undef, n+1, m) for H in Hs)
for H in Hs
    for i in 1:m
        rand!(rng, noise[H], view(W[H], :, i))
    end
end

means = Dict(H =&gt; mean(W[H], dims=2) for H in Hs)
stds = Dict(H =&gt; std(W[H], dims=2) for H in Hs)</code></pre><pre><code class="language-julia hljs">H = Hs[3]

plt = plot(title=&quot;Sample paths, mean, and std&quot;)
plot!(plt, tt, view(W[H], :, 1:100), alpha=0.05, color=1, label=nothing)
plot!(plt, tt, means[H], label=&quot;Mean&quot;)
plot!(plt, tt, means[H] .+ stds[H], label=&quot;Stds&quot;, color=7)
plot!(plt, tt, means[H] .- stds[H], label=nothing, color=7)
plot!(plt, tt, tt.^H, label=&quot;theoretical&quot;, color=:black, style=:dash)
plot!(plt, tt, -tt.^H, label=nothing, color=:black, style=:dash)</code></pre><img src="a25cfc5e.svg" alt="Example block output"/><p>Now with <span>$H=1/2$</span>.</p><pre><code class="language-julia hljs">H = Hs[2]

plt = plot(title=&quot;Sample paths, mean, and std&quot;)
plot!(plt, tt, view(W[H], :, 1:100), alpha=0.05, color=1, label=nothing)
plot!(plt, tt, means[H], label=&quot;Mean&quot;)
plot!(plt, tt, means[H] .+ stds[H], label=&quot;Stds&quot;, color=7)
plot!(plt, tt, means[H] .- stds[H], label=nothing, color=7)
plot!(plt, tt, tt.^H, label=&quot;theoretical&quot;, color=:black, style=:dash)
plot!(plt, tt, -tt.^H, label=nothing, color=:black, style=:dash)</code></pre><img src="5f5314a8.svg" alt="Example block output"/><p>Finally with <span>$0 &lt; H &lt; 1/2$</span>.</p><pre><code class="language-julia hljs">H = Hs[1]

plt = plot(title=&quot;Sample paths, mean, and std&quot;)
plot!(plt, tt, view(W[H], :, 1:100), alpha=0.05, color=1, label=nothing)
plot!(plt, tt, means[H], label=&quot;Mean&quot;)
plot!(plt, tt, means[H] .+ stds[H], label=&quot;Stds&quot;, color=7)
plot!(plt, tt, means[H] .- stds[H], label=nothing, color=7)
plot!(plt, tt, tt.^H, label=&quot;theoretical&quot;, color=:black, style=:dash)
plot!(plt, tt, -tt.^H, label=nothing, color=:black, style=:dash)</code></pre><img src="74008929.svg" alt="Example block output"/><h2 id="Checking-the-probability-distribution-function"><a class="docs-heading-anchor" href="#Checking-the-probability-distribution-function">Checking the probability distribution function</a><a id="Checking-the-probability-distribution-function-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-the-probability-distribution-function" title="Permalink"></a></h2><p>At each time <span>$t$</span>, the distribution of <span>$B_H(t)$</span> is a Normal distribution with mean 0 and standard deviation <span>$t^H$</span>. So we check this by plotting the normalized histogram of the simulated paths, along with the theoretical distribution, for a few instants of time.</p><pre><code class="language-julia hljs">H = Hs[1]
xx = -3*last(tt)^H:0.01:3*last(tt)^H
plts = []
for ni in div.(n, (100, 10, 2, 1))
    plt = plot(title=&quot;Histogram and PDF for H=$H at t=$(round(tt[ni], sigdigits=3))&quot;, xlims=(first(xx), last(xx)), titlefont=8, legend=nothing)
    histogram!(plt, view(W[H], ni, :), bins=40, normalize=true)
    plot!(plt, xx, x -&gt; pdf(Normal(0.0, tt[ni]^H), x))
    push!(plts, plt)
end
plot(plts...)</code></pre><img src="893e9251.svg" alt="Example block output"/><pre><code class="language-julia hljs">H = Hs[2]
xx = -3*last(tt)^H:0.01:3*last(tt)^H
plts = []
for ni in div.(n, (100, 10, 2, 1))
    plt = plot(title=&quot;Histogram and PDF for H=$H at t=$(round(tt[ni], sigdigits=3))&quot;, xlims=(first(xx), last(xx)), titlefont=8, legend=nothing)
    histogram!(plt, view(W[H], ni, :), bins=40, normalize=true)
    plot!(plt, xx, x -&gt; pdf(Normal(0.0, tt[ni]^H), x))
    push!(plts, plt)
end
plot(plts...)</code></pre><img src="c2896568.svg" alt="Example block output"/><pre><code class="language-julia hljs">H = Hs[3]
xx = -3*last(tt)^H:0.01:3*last(tt)^H
plts = []
for ni in div.(n, (100, 10, 2, 1))
    plt = plot(title=&quot;Histogram and PDF for H=$H at t=$(round(tt[ni], sigdigits=3))&quot;, xlims=(first(xx), last(xx)), titlefont=8, legend=nothing)
    histogram!(plt, view(W[H], ni, :), bins=40, normalize=true)
    plot!(plt, xx, x -&gt; pdf(Normal(0.0, tt[ni]^H), x))
    push!(plts, plt)
end
plot(plts...)</code></pre><img src="6c5d4523.svg" alt="Example block output"/><h2 id="Checking-the-covariance"><a class="docs-heading-anchor" href="#Checking-the-covariance">Checking the covariance</a><a id="Checking-the-covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-the-covariance" title="Permalink"></a></h2><p>In theory, the covariance of a fractional Brownian motion <span>$\{B_H(t)\}_{t}$</span> with Hurst parameter <span>$H$</span> should be given by</p><p class="math-container">\[    \rho(t, s) = \mathbb{E}[B_H(t)B_H(s)] = \frac{1}{2}\left\{ t^{2H} + s^{2H} - |t - s|^{2H}\right\}.\]</p><p>So, we compute the covariance from the generated sample paths and check the relative difference from the expected exact covariance:</p><pre><code class="language-julia hljs">H = Hs[1]
covmatW = cov(W[H], dims=2, corrected=false)
covmat = [0.5*(t^(2H) + s^(2H) - abs(t - s)^(2H)) for t in tt, s in tt]
extrema(covmatW .- covmat)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-0.3486965755722605, 0.0949561240462552)</code></pre><p>Let us visualize the covariance of the sample paths:</p><pre><code class="language-julia hljs">heatmap(tt, tt, covmatW, title=&quot;Covariance of the generated samples&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;s&quot;)</code></pre><img src="ab6c0dcd.svg" alt="Example block output"/><p>And compare it with the theoretical covariance:</p><pre><code class="language-julia hljs">heatmap(tt, tt, covmat, title=&quot;Theoretical covariance&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;s&quot;)</code></pre><img src="56e26bd0.svg" alt="Example block output"/><p>Apparently there are just numerical errors. Here are the heatmap and the surface plots of the difference:</p><pre><code class="language-julia hljs">heatmap(tt, tt, covmatW .- covmat, title=&quot;Difference&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;s&quot;)</code></pre><img src="97bdbb02.svg" alt="Example block output"/><pre><code class="language-julia hljs">surface(tt, tt, covmatW .- covmat, title=&quot;Difference&quot;, titlefont=8, xlabel=&quot;t&quot;, ylabel=&quot;s&quot;)</code></pre><img src="a54d195b.svg" alt="Example block output"/><p>Looks good!</p><h2 id="Benchmark"><a class="docs-heading-anchor" href="#Benchmark">Benchmark</a><a id="Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark" title="Permalink"></a></h2><p>The function <code>fBm_noise(t0, T, y0, H, N)</code> returns a fractional Brownian motion <em>sampler.</em> That means when we set <code>noise = FractionalBrownianMotionProcess(t0, T, y0, H, N)</code>, then <code>noise</code> is a sampler, from which we draw sample paths with <code>rand!(rng, noise, Yt)</code>, filling up the preallocated vector <code>Yt</code> with a sample path.</p><p>When calling <code>FractionalBrownianMotionProcess(t0, T, y0, H, N)</code>, a composite type is created containing cache vectors to hold the intermediate results needed when generating each sample path, including going through inverse and direct fast Fourier transforms. Besised creating the auxiliary cache vectors, it also builds the FFT plans used in the FFT transforms via <a href="https://github.com/JuliaMath/FFTW.jl">FFTW.jl</a>. In this way, the resulting sampler <code>noise</code> contains everthing pre-allocated so generating a sample is non-allocating. This can be benchmarked as follows.</p><pre><code class="language-julia hljs">H = Hs[1]
@btime rand!($rng, $(noise[H]), $yt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  49.673 μs (0 allocations: 0 bytes)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../homlin/">« Homogeneous linear Itô process noise</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 18:05">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
